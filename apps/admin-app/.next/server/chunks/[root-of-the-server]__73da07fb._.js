module.exports = [
"[project]/apps/admin-app/.next-internal/server/app/api/admin/files/route/actions.js [app-rsc] (server actions loader, ecmascript)", ((__turbopack_context__, module, exports) => {

}),
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/action-async-storage.external.js [external] (next/dist/server/app-render/action-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/action-async-storage.external.js", () => require("next/dist/server/app-render/action-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/firebase-admin/app [external] (firebase-admin/app, esm_import)", ((__turbopack_context__) => {
"use strict";

return __turbopack_context__.a(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {

const mod = await __turbopack_context__.y("firebase-admin/app");

__turbopack_context__.n(mod);
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, true);}),
"[externals]/firebase-admin/auth [external] (firebase-admin/auth, esm_import)", ((__turbopack_context__) => {
"use strict";

return __turbopack_context__.a(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {

const mod = await __turbopack_context__.y("firebase-admin/auth");

__turbopack_context__.n(mod);
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, true);}),
"[externals]/firebase-admin/firestore [external] (firebase-admin/firestore, esm_import)", ((__turbopack_context__) => {
"use strict";

return __turbopack_context__.a(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {

const mod = await __turbopack_context__.y("firebase-admin/firestore");

__turbopack_context__.n(mod);
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, true);}),
"[externals]/firebase-admin/storage [external] (firebase-admin/storage, esm_import)", ((__turbopack_context__) => {
"use strict";

return __turbopack_context__.a(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {

const mod = await __turbopack_context__.y("firebase-admin/storage");

__turbopack_context__.n(mod);
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, true);}),
"[project]/apps/admin-app/src/lib/firebase-admin.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

return __turbopack_context__.a(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {

__turbopack_context__.s([
    "adminAuth",
    ()=>adminAuth,
    "adminDb",
    ()=>adminDb,
    "adminStorage",
    ()=>adminStorage,
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$firebase$2d$admin$2f$app__$5b$external$5d$__$28$firebase$2d$admin$2f$app$2c$__esm_import$29$__ = __turbopack_context__.i("[externals]/firebase-admin/app [external] (firebase-admin/app, esm_import)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$firebase$2d$admin$2f$auth__$5b$external$5d$__$28$firebase$2d$admin$2f$auth$2c$__esm_import$29$__ = __turbopack_context__.i("[externals]/firebase-admin/auth [external] (firebase-admin/auth, esm_import)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$firebase$2d$admin$2f$firestore__$5b$external$5d$__$28$firebase$2d$admin$2f$firestore$2c$__esm_import$29$__ = __turbopack_context__.i("[externals]/firebase-admin/firestore [external] (firebase-admin/firestore, esm_import)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$firebase$2d$admin$2f$storage__$5b$external$5d$__$28$firebase$2d$admin$2f$storage$2c$__esm_import$29$__ = __turbopack_context__.i("[externals]/firebase-admin/storage [external] (firebase-admin/storage, esm_import)");
var __turbopack_async_dependencies__ = __turbopack_handle_async_dependencies__([
    __TURBOPACK__imported__module__$5b$externals$5d2f$firebase$2d$admin$2f$app__$5b$external$5d$__$28$firebase$2d$admin$2f$app$2c$__esm_import$29$__,
    __TURBOPACK__imported__module__$5b$externals$5d2f$firebase$2d$admin$2f$auth__$5b$external$5d$__$28$firebase$2d$admin$2f$auth$2c$__esm_import$29$__,
    __TURBOPACK__imported__module__$5b$externals$5d2f$firebase$2d$admin$2f$firestore__$5b$external$5d$__$28$firebase$2d$admin$2f$firestore$2c$__esm_import$29$__,
    __TURBOPACK__imported__module__$5b$externals$5d2f$firebase$2d$admin$2f$storage__$5b$external$5d$__$28$firebase$2d$admin$2f$storage$2c$__esm_import$29$__
]);
[__TURBOPACK__imported__module__$5b$externals$5d2f$firebase$2d$admin$2f$app__$5b$external$5d$__$28$firebase$2d$admin$2f$app$2c$__esm_import$29$__, __TURBOPACK__imported__module__$5b$externals$5d2f$firebase$2d$admin$2f$auth__$5b$external$5d$__$28$firebase$2d$admin$2f$auth$2c$__esm_import$29$__, __TURBOPACK__imported__module__$5b$externals$5d2f$firebase$2d$admin$2f$firestore__$5b$external$5d$__$28$firebase$2d$admin$2f$firestore$2c$__esm_import$29$__, __TURBOPACK__imported__module__$5b$externals$5d2f$firebase$2d$admin$2f$storage__$5b$external$5d$__$28$firebase$2d$admin$2f$storage$2c$__esm_import$29$__] = __turbopack_async_dependencies__.then ? (await __turbopack_async_dependencies__)() : __turbopack_async_dependencies__;
;
;
;
;
// Initialize Firebase Admin
const privateKey = process.env.FIREBASE_PRIVATE_KEY?.replace(/^"|"$/g, '') || '';
const firebaseAdminConfig = {
    credential: (0, __TURBOPACK__imported__module__$5b$externals$5d2f$firebase$2d$admin$2f$app__$5b$external$5d$__$28$firebase$2d$admin$2f$app$2c$__esm_import$29$__["cert"])({
        projectId: process.env.FIREBASE_PROJECT_ID,
        clientEmail: process.env.FIREBASE_CLIENT_EMAIL,
        privateKey: privateKey
    })
};
// Initialize Firebase Admin
const adminApp = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$firebase$2d$admin$2f$app__$5b$external$5d$__$28$firebase$2d$admin$2f$app$2c$__esm_import$29$__["getApps"])().length === 0 ? (0, __TURBOPACK__imported__module__$5b$externals$5d2f$firebase$2d$admin$2f$app__$5b$external$5d$__$28$firebase$2d$admin$2f$app$2c$__esm_import$29$__["initializeApp"])(firebaseAdminConfig) : (0, __TURBOPACK__imported__module__$5b$externals$5d2f$firebase$2d$admin$2f$app__$5b$external$5d$__$28$firebase$2d$admin$2f$app$2c$__esm_import$29$__["getApps"])()[0];
const adminAuth = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$firebase$2d$admin$2f$auth__$5b$external$5d$__$28$firebase$2d$admin$2f$auth$2c$__esm_import$29$__["getAuth"])(adminApp);
const adminDb = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$firebase$2d$admin$2f$firestore__$5b$external$5d$__$28$firebase$2d$admin$2f$firestore$2c$__esm_import$29$__["getFirestore"])(adminApp);
const adminStorage = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$firebase$2d$admin$2f$storage__$5b$external$5d$__$28$firebase$2d$admin$2f$storage$2c$__esm_import$29$__["getStorage"])(adminApp);
const __TURBOPACK__default__export__ = adminApp;
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, false);}),
"[project]/apps/admin-app/src/lib/server-cache.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "makeKey",
    ()=>makeKey,
    "serverCache",
    ()=>serverCache
]);
class SimpleLRUCache {
    maxEntries;
    store;
    order;
    constructor(maxEntries = 200){
        this.maxEntries = maxEntries;
        this.store = new Map();
        this.order = [];
    }
    get(key) {
        const entry = this.store.get(key);
        if (!entry) return undefined;
        if (Date.now() > entry.expiresAt) {
            this.delete(key);
            return undefined;
        }
        // touch
        this.order = this.order.filter((k)=>k !== key);
        this.order.push(key);
        return entry.data;
    }
    set(key, value, ttlMs) {
        const expiresAt = Date.now() + ttlMs;
        this.store.set(key, {
            data: value,
            expiresAt
        });
        this.order = this.order.filter((k)=>k !== key);
        this.order.push(key);
        // evict
        while(this.order.length > this.maxEntries){
            const oldest = this.order.shift();
            if (oldest) this.store.delete(oldest);
        }
    }
    delete(key) {
        this.store.delete(key);
        this.order = this.order.filter((k)=>k !== key);
    }
    deleteByPrefix(prefix) {
        for (const key of Array.from(this.store.keys())){
            if (key.startsWith(prefix)) this.delete(key);
        }
    }
}
const serverCache = new SimpleLRUCache(300);
function makeKey(resource, parts = []) {
    return `admin:${resource}:${parts.filter((v)=>v !== undefined && v !== null).join(':')}`;
}
}),
"[project]/apps/admin-app/src/lib/admin-auth.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

return __turbopack_context__.a(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {

__turbopack_context__.s([
    "getQueryParams",
    ()=>getQueryParams,
    "verifyAdminAuth",
    ()=>verifyAdminAuth
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$headers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/headers.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$admin$2d$app$2f$src$2f$lib$2f$firebase$2d$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/admin-app/src/lib/firebase-admin.ts [app-route] (ecmascript)");
var __turbopack_async_dependencies__ = __turbopack_handle_async_dependencies__([
    __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$admin$2d$app$2f$src$2f$lib$2f$firebase$2d$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__
]);
[__TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$admin$2d$app$2f$src$2f$lib$2f$firebase$2d$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__] = __turbopack_async_dependencies__.then ? (await __turbopack_async_dependencies__)() : __turbopack_async_dependencies__;
;
;
async function verifyAdminAuth() {
    try {
        const cookieStore = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$headers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["cookies"])();
        const token = cookieStore.get('admin-token')?.value;
        // For development, we'll allow access with a simple token check
        if (token === 'dev_admin_token') {
            return {
                adminId: "dev_admin",
                name: "Development Admin",
                email: "admin@docuploaer.com",
                role: "admin"
            };
        }
        if (!token) {
            throw new Error('No admin authentication token found');
        }
        // Verify the token with Firebase Admin
        const decodedToken = await __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$admin$2d$app$2f$src$2f$lib$2f$firebase$2d$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["adminAuth"].verifyIdToken(token);
        // Check if this is a custom token with admin role
        if (decodedToken.role === 'admin') {
            return {
                adminId: decodedToken.adminId || decodedToken.uid,
                name: decodedToken.name || 'Admin',
                email: decodedToken.email || 'admin@example.com',
                role: "admin"
            };
        }
        // Get admin data from admins collection
        const adminDoc = await __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$admin$2d$app$2f$src$2f$lib$2f$firebase$2d$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["adminDb"].collection('admins').doc(decodedToken.uid).get();
        if (!adminDoc.exists) {
            throw new Error('Admin not found in database');
        }
        const adminData = adminDoc.data();
        if (!adminData?.isActive) {
            throw new Error('Admin account is deactivated');
        }
        return {
            adminId: decodedToken.uid,
            name: adminData.name,
            email: adminData.email,
            role: "admin"
        };
    } catch (error) {
        // For development, return default admin even on error
        return {
            adminId: "dev_admin",
            name: "Development Admin",
            email: "admin@docuploaer.com",
            role: "admin"
        };
    }
}
function getQueryParams(request) {
    const { searchParams } = new URL(request.url);
    return {
        filter: searchParams.get('filter') || 'all',
        dateFilter: searchParams.get('dateFilter') || 'all',
        search: searchParams.get('search') || '',
        limit: parseInt(searchParams.get('limit') || '50'),
        offset: parseInt(searchParams.get('offset') || '0'),
        status: searchParams.get('status'),
        userId: searchParams.get('userId'),
        fileId: searchParams.get('fileId'),
        startDate: searchParams.get('startDate'),
        endDate: searchParams.get('endDate')
    };
}
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, false);}),
"[project]/apps/admin-app/src/app/api/admin/files/route.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

return __turbopack_context__.a(async (__turbopack_handle_async_dependencies__, __turbopack_async_result__) => { try {

__turbopack_context__.s([
    "DELETE",
    ()=>DELETE,
    "GET",
    ()=>GET,
    "PATCH",
    ()=>PATCH,
    "PUT",
    ()=>PUT
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$admin$2d$app$2f$src$2f$lib$2f$firebase$2d$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/admin-app/src/lib/firebase-admin.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$firebase$2d$admin$2f$firestore__$5b$external$5d$__$28$firebase$2d$admin$2f$firestore$2c$__esm_import$29$__ = __turbopack_context__.i("[externals]/firebase-admin/firestore [external] (firebase-admin/firestore, esm_import)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$admin$2d$app$2f$src$2f$lib$2f$server$2d$cache$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/admin-app/src/lib/server-cache.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$admin$2d$app$2f$src$2f$lib$2f$admin$2d$auth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/apps/admin-app/src/lib/admin-auth.ts [app-route] (ecmascript)");
var __turbopack_async_dependencies__ = __turbopack_handle_async_dependencies__([
    __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$admin$2d$app$2f$src$2f$lib$2f$firebase$2d$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__,
    __TURBOPACK__imported__module__$5b$externals$5d2f$firebase$2d$admin$2f$firestore__$5b$external$5d$__$28$firebase$2d$admin$2f$firestore$2c$__esm_import$29$__,
    __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$admin$2d$app$2f$src$2f$lib$2f$admin$2d$auth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__
]);
[__TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$admin$2d$app$2f$src$2f$lib$2f$firebase$2d$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__, __TURBOPACK__imported__module__$5b$externals$5d2f$firebase$2d$admin$2f$firestore__$5b$external$5d$__$28$firebase$2d$admin$2f$firestore$2c$__esm_import$29$__, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$admin$2d$app$2f$src$2f$lib$2f$admin$2d$auth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__] = __turbopack_async_dependencies__.then ? (await __turbopack_async_dependencies__)() : __turbopack_async_dependencies__;
;
;
;
;
;
// Helper function to handle Firestore connection issues with retry logic
async function withRetry(operation, maxRetries = 3, delay = 1000) {
    let lastError;
    for(let attempt = 1; attempt <= maxRetries; attempt++){
        try {
            return await operation();
        } catch (error) {
            lastError = error;
            // Check if it's a connection error that we should retry
            if (error.code === 14 || // UNAVAILABLE
            error.message?.includes('No connection established') || error.message?.includes('network socket disconnected') || error.message?.includes('TLS connection') || error.code === 'ECONNRESET' || error.code === 'ENOTFOUND') {
                // Retrying...
                if (attempt < maxRetries) {
                    await new Promise((resolve)=>setTimeout(resolve, delay));
                    delay *= 2; // Exponential backoff
                    continue;
                }
            }
            // If it's not a retryable error or we've exhausted retries, throw
            throw error;
        }
    }
    throw lastError;
}
// Helper function to trigger automatic assignment for paid files
async function triggerAutoAssignment(fileIds) {
    try {
        console.log(`[AUTO-ASSIGN] Triggering auto-assignment for ${fileIds.length} files`);
        // Get all active agents
        const agentsSnapshot = await withRetry(()=>__TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$admin$2d$app$2f$src$2f$lib$2f$firebase$2d$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["adminDb"].collection('agents').where('isActive', '==', true).get());
        if (agentsSnapshot.empty) {
            console.log('[AUTO-ASSIGN] No active agents found');
            return {
                success: false,
                error: 'No active agents found'
            };
        }
        // OPTIMIZED: Get ALL assigned files with limit to prevent huge queries
        const allAssignedFilesSnapshot = await withRetry(()=>__TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$admin$2d$app$2f$src$2f$lib$2f$firebase$2d$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["adminDb"].collection('files').where('status', 'in', [
                'paid',
                'assigned',
                'in_progress'
            ]).limit(2000) // Limit to prevent huge queries
            .get());
        // Build workload map from single query result
        const workloadMap = new Map();
        allAssignedFilesSnapshot.docs.forEach((doc)=>{
            const agentId = doc.data().assignedAgentId;
            if (agentId) {
                workloadMap.set(agentId, (workloadMap.get(agentId) || 0) + 1);
            }
        });
        // Calculate current workload for each agent (no additional queries needed!)
        const agentWorkloads = agentsSnapshot.docs.map((agentDoc)=>{
            const agentData = agentDoc.data();
            const agentId = agentDoc.id;
            return {
                agentId,
                agentName: agentData.name || 'Unknown Agent',
                agentEmail: agentData.email || 'No email',
                currentWorkload: workloadMap.get(agentId) || 0,
                maxWorkload: agentData.maxWorkload || 20,
                isActive: agentData.isActive || false,
                lastAssigned: agentData.lastAssigned || null
            };
        });
        // Sort agents by workload (least loaded first)
        const sortedAgents = agentWorkloads.filter((agent)=>agent.isActive).sort((a, b)=>{
            if (a.currentWorkload !== b.currentWorkload) {
                return a.currentWorkload - b.currentWorkload;
            }
            if (a.lastAssigned && b.lastAssigned) {
                return new Date(a.lastAssigned).getTime() - new Date(b.lastAssigned).getTime();
            }
            if (!a.lastAssigned && b.lastAssigned) return -1;
            if (a.lastAssigned && !b.lastAssigned) return 1;
            return 0;
        });
        if (sortedAgents.length === 0) {
            console.log('[AUTO-ASSIGN] No available agents for assignment');
            return {
                success: false,
                error: 'No available agents for assignment'
            };
        }
        // Assign files to agents using round-robin with workload consideration
        const assignments = [];
        const agentUpdates = new Map();
        let agentIndex = 0;
        // OPTIMIZED: Use Firestore batch writes (up to 500 operations per batch)
        const batch = __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$admin$2d$app$2f$src$2f$lib$2f$firebase$2d$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["adminDb"].batch();
        let operationCount = 0;
        const MAX_BATCH_SIZE = 500;
        for (const fileId of fileIds){
            // Find the best agent for this file
            let selectedAgent = null;
            // Try to find an agent with available capacity
            for(let i = 0; i < sortedAgents.length; i++){
                const agent = sortedAgents[agentIndex % sortedAgents.length];
                agentIndex++;
                if (agent.currentWorkload < agent.maxWorkload) {
                    selectedAgent = agent;
                    break;
                }
            }
            // If no agent has capacity, assign to the least loaded one
            if (!selectedAgent) {
                selectedAgent = sortedAgents[0];
            }
            // Add file update to batch
            const fileRef = __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$admin$2d$app$2f$src$2f$lib$2f$firebase$2d$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["adminDb"].collection('files').doc(fileId);
            batch.update(fileRef, {
                assignedAgentId: selectedAgent.agentId,
                assignedAt: new Date(),
                status: 'assigned',
                updatedAt: new Date()
            });
            operationCount++;
            // Track agent update (will be batched later)
            agentUpdates.set(selectedAgent.agentId, new Date());
            // Update agent's workload count
            selectedAgent.currentWorkload++;
            assignments.push({
                fileId,
                agentId: selectedAgent.agentId,
                agentName: selectedAgent.agentName,
                workload: selectedAgent.currentWorkload
            });
            // Commit batch if we hit the limit
            if (operationCount >= MAX_BATCH_SIZE) {
                await batch.commit();
                operationCount = 0;
            }
        }
        // Add agent updates to batch
        agentUpdates.forEach((lastAssigned, agentId)=>{
            const agentRef = __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$admin$2d$app$2f$src$2f$lib$2f$firebase$2d$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["adminDb"].collection('agents').doc(agentId);
            batch.update(agentRef, {
                lastAssigned,
                updatedAt: new Date()
            });
            operationCount++;
        });
        // Commit any remaining operations
        if (operationCount > 0) {
            await batch.commit();
        }
        return {
            success: true,
            message: `Successfully auto-assigned ${fileIds.length} file(s)`,
            assignments: assignments,
            totalAssigned: fileIds.length
        };
    } catch (error) {
        console.error('[AUTO-ASSIGN] Error in auto-assignment:', error);
        return {
            success: false,
            error: 'Auto-assignment failed'
        };
    }
}
async function GET(request) {
    try {
        // Verify admin authentication
        const admin = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$admin$2d$app$2f$src$2f$lib$2f$admin$2d$auth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["verifyAdminAuth"])();
        if (!admin) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                success: false,
                error: 'Unauthorized'
            }, {
                status: 401
            });
        }
        const { searchParams } = new URL(request.url);
        const page = parseInt(searchParams.get('page') || '1');
        const limit = parseInt(searchParams.get('limit') || '50');
        const search = searchParams.get('search') || '';
        const status = searchParams.get('status') || 'all';
        const assignedAgent = searchParams.get('assignedAgent') || 'all';
        const fresh = searchParams.get('fresh') === '1';
        const cacheKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$admin$2d$app$2f$src$2f$lib$2f$server$2d$cache$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["makeKey"])('files', [
            'list',
            page,
            limit,
            status || 'all',
            assignedAgent || 'all',
            search || ''
        ]);
        const cached = fresh ? undefined : __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$admin$2d$app$2f$src$2f$lib$2f$server$2d$cache$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["serverCache"].get(cacheKey);
        if (cached) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json(cached);
        }
        // Build optimized query with filters at database level
        let baseQuery = __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$admin$2d$app$2f$src$2f$lib$2f$firebase$2d$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["adminDb"].collection('files');
        // Apply status filter at database level
        if (status !== 'all') {
            baseQuery = baseQuery.where('status', '==', status);
        }
        // Apply agent filter at database level
        if (assignedAgent !== 'all') {
            baseQuery = baseQuery.where('assignedAgentId', '==', assignedAgent);
        }
        // Prefer indexed sort when available
        let filesSnapshot;
        try {
            const indexedQuery = baseQuery.orderBy('uploadedAt', 'desc').limit(1000);
            filesSnapshot = await withRetry(()=>indexedQuery.get());
        } catch (err) {
            // Fallback if composite index is missing: fetch without orderBy and sort in memory
            if (err?.code === 9 || err?.message?.includes('requires an index')) {
                const fallbackSnapshot = await withRetry(()=>baseQuery.limit(1000).get());
                // Sort docs in-memory by uploadedAt desc to preserve expected ordering
                const sortedDocs = fallbackSnapshot.docs.sort((a, b)=>{
                    const aTime = a.data()?.uploadedAt?.toDate?.()?.getTime?.() ?? new Date(a.data()?.uploadedAt || 0).getTime();
                    const bTime = b.data()?.uploadedAt?.toDate?.()?.getTime?.() ?? new Date(b.data()?.uploadedAt || 0).getTime();
                    return bTime - aTime;
                });
                // Create a lightweight snapshot-like object
                filesSnapshot = {
                    docs: sortedDocs,
                    empty: sortedDocs.length === 0,
                    forEach: (cb)=>sortedDocs.forEach(cb),
                    size: sortedDocs.length,
                    // Unused properties in our code path; add minimal stubs to satisfy types
                    metadata: undefined,
                    query: undefined
                };
            } else {
                throw err;
            }
        }
        // Extract unique user and agent IDs for batch fetching
        const userIds = new Set();
        const agentIds = new Set();
        const filesData = filesSnapshot.docs.map((doc)=>{
            const data = doc.data();
            if (data.userId) userIds.add(data.userId);
            if (data.assignedAgentId) agentIds.add(data.assignedAgentId);
            return {
                id: doc.id,
                ...data
            };
        });
        // OPTIMIZED: Batch fetch users and agents with limits
        const [usersSnapshot, agentsSnapshot] = await Promise.all([
            userIds.size > 0 ? withRetry(()=>__TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$admin$2d$app$2f$src$2f$lib$2f$firebase$2d$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["adminDb"].collection('users').where(__TURBOPACK__imported__module__$5b$externals$5d2f$firebase$2d$admin$2f$firestore__$5b$external$5d$__$28$firebase$2d$admin$2f$firestore$2c$__esm_import$29$__["FieldPath"].documentId(), 'in', Array.from(userIds).slice(0, 10)).limit(100) // Additional limit
                .get()) : Promise.resolve({
                docs: []
            }),
            agentIds.size > 0 ? withRetry(()=>__TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$admin$2d$app$2f$src$2f$lib$2f$firebase$2d$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["adminDb"].collection('agents').where(__TURBOPACK__imported__module__$5b$externals$5d2f$firebase$2d$admin$2f$firestore__$5b$external$5d$__$28$firebase$2d$admin$2f$firestore$2c$__esm_import$29$__["FieldPath"].documentId(), 'in', Array.from(agentIds).slice(0, 10)).limit(100) // Additional limit
                .get()) : Promise.resolve({
                docs: []
            })
        ]);
        // Skip additional batch processing for performance - use only first 10 IDs
        // This prevents excessive queries that slow down the API
        // Create lookup maps for O(1) access
        const usersMap = new Map();
        usersSnapshot.docs.forEach((doc)=>{
            const data = doc.data();
            usersMap.set(doc.id, {
                id: doc.id,
                name: data?.name || 'Unknown',
                email: data?.email || 'Unknown',
                phone: data?.phone || 'Unknown'
            });
        });
        const agentsMap = new Map();
        agentsSnapshot.docs.forEach((doc)=>{
            const data = doc.data();
            agentsMap.set(doc.id, {
                id: doc.id,
                name: data?.name || 'Unknown',
                email: data?.email || 'Unknown',
                phone: data?.phone || 'Unknown'
            });
        });
        // Map files with user and agent data from lookup maps (O(N) instead of O(N*M))
        let files = filesData.map((data)=>({
                id: data.id,
                filename: data.filename || 'Unknown',
                originalName: data.originalName || 'Unknown',
                size: data.size || 0,
                mimeType: data.mimeType || 'Unknown',
                status: data.status || 'unknown',
                uploadedAt: data.uploadedAt?.toDate?.() || data.uploadedAt || new Date(),
                assignedAt: data.assignedAt?.toDate?.() || data.assignedAt || null,
                respondedAt: data.respondedAt?.toDate?.() || data.respondedAt || null,
                responseFileURL: data.responseFileURL || null,
                responseMessage: data.responseMessage || null,
                user: data.userId ? usersMap.get(data.userId) || null : null,
                agent: data.assignedAgentId ? agentsMap.get(data.assignedAgentId) || null : null,
                paymentId: data.paymentId || null
            }));
        // Apply search filter
        if (search) {
            const searchLower = search.toLowerCase();
            files = files.filter((file)=>file.filename.toLowerCase().includes(searchLower) || file.originalName.toLowerCase().includes(searchLower) || file.user?.name?.toLowerCase().includes(searchLower) || file.user?.email?.toLowerCase().includes(searchLower) || file.agent?.name?.toLowerCase().includes(searchLower));
        }
        // Apply pagination
        const totalFiles = files.length;
        const startIndex = (Number(page) - 1) * Number(limit);
        const endIndex = startIndex + Number(limit);
        const paginatedFiles = files.slice(startIndex, endIndex);
        const responsePayload = {
            success: true,
            files: paginatedFiles,
            pagination: {
                page: Number(page),
                limit: Number(limit),
                total: totalFiles,
                pages: Math.ceil(totalFiles / Number(limit))
            }
        };
        // Use shorter TTL to reduce staleness after payments; skip caching if explicitly fresh
        if (!fresh) {
            __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$admin$2d$app$2f$src$2f$lib$2f$server$2d$cache$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["serverCache"].set(cacheKey, responsePayload, 10_000); // 10s TTL for fresher files list
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json(responsePayload);
    } catch (error) {
        console.error('Error fetching files:', error);
        // Handle specific error types
        if (error.code === 14 || error.message?.includes('No connection established')) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                success: false,
                error: "Database connection failed. Please try again."
            }, {
                status: 503
            });
        }
        if (error.name === 'AbortError' || error.message?.includes('timeout')) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                success: false,
                error: "Request timed out. Please try again."
            }, {
                status: 408
            });
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: false,
            error: 'Failed to fetch files'
        }, {
            status: 500
        });
    }
}
async function PATCH(request) {
    try {
        // Verify admin authentication
        const admin = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$admin$2d$app$2f$src$2f$lib$2f$admin$2d$auth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["verifyAdminAuth"])();
        if (!admin) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                success: false,
                error: 'Unauthorized'
            }, {
                status: 401
            });
        }
        const { fileId, status, assignedAgentId, responseMessage } = await request.json();
        if (!fileId) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                success: false,
                error: 'File ID is required'
            }, {
                status: 400
            });
        }
        const updateData = {};
        if (status) {
            updateData.status = status;
        }
        if (assignedAgentId) {
            updateData.assignedAgentId = assignedAgentId;
            updateData.assignedAt = new Date();
        }
        if (responseMessage) {
            updateData.responseMessage = responseMessage;
        }
        updateData.updatedAt = new Date();
        await __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$admin$2d$app$2f$src$2f$lib$2f$firebase$2d$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["adminDb"].collection('files').doc(fileId).update(updateData);
        __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$admin$2d$app$2f$src$2f$lib$2f$server$2d$cache$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["serverCache"].deleteByPrefix((0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$admin$2d$app$2f$src$2f$lib$2f$server$2d$cache$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["makeKey"])('files'));
        // Auto-assign if file status changed to 'paid' and no agent is assigned
        if (status === 'paid' && !assignedAgentId) {
            try {
                console.log('File marked as paid, triggering auto-assignment for:', fileId);
                const autoAssignResult = await triggerAutoAssignment([
                    fileId
                ]);
                if (autoAssignResult.success) {
                    console.log('Auto-assignment successful:', autoAssignResult);
                } else {
                    console.error('Auto-assignment failed:', autoAssignResult);
                }
            } catch (error) {
                console.error('Error in auto-assignment trigger:', error);
            }
        }
        // Log the action
        await __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$admin$2d$app$2f$src$2f$lib$2f$firebase$2d$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["adminDb"].collection('logs').add({
            action: 'file_updated',
            adminId: admin.adminId,
            adminName: admin.name,
            fileId,
            changes: updateData,
            autoAssigned: status === 'paid' && !assignedAgentId,
            timestamp: new Date()
        });
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: true,
            message: 'File updated successfully'
        });
    } catch (error) {
        console.error('Error updating file:', error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: false,
            error: 'Failed to update file'
        }, {
            status: 500
        });
    }
}
async function PUT(request) {
    try {
        const admin = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$admin$2d$app$2f$src$2f$lib$2f$admin$2d$auth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["verifyAdminAuth"])();
        if (!admin) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                success: false,
                error: 'Unauthorized'
            }, {
                status: 401
            });
        }
        const { fileId, status, triggerAutoAssign = false } = await request.json();
        if (!fileId || !status) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                success: false,
                error: 'File ID and status are required'
            }, {
                status: 400
            });
        }
        // Update file status
        const updateData = {
            status,
            updatedAt: new Date()
        };
        await __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$admin$2d$app$2f$src$2f$lib$2f$firebase$2d$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["adminDb"].collection('files').doc(fileId).update(updateData);
        __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$admin$2d$app$2f$src$2f$lib$2f$server$2d$cache$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["serverCache"].deleteByPrefix((0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$admin$2d$app$2f$src$2f$lib$2f$server$2d$cache$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["makeKey"])('files'));
        // If status is 'paid' and auto-assignment is enabled, trigger it
        if (status === 'paid' && triggerAutoAssign) {
            const autoAssignResult = await triggerAutoAssignment([
                fileId
            ]);
            if (autoAssignResult.success) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                    success: true,
                    message: 'File status updated and auto-assigned successfully',
                    autoAssignment: autoAssignResult
                });
            } else {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                    success: true,
                    message: 'File status updated, but auto-assignment failed',
                    autoAssignment: autoAssignResult
                });
            }
        }
        // Log the action
        await __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$admin$2d$app$2f$src$2f$lib$2f$firebase$2d$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["adminDb"].collection('logs').add({
            action: 'file_status_updated',
            adminId: admin.adminId,
            adminName: admin.name,
            fileId,
            newStatus: status,
            triggerAutoAssign,
            timestamp: new Date()
        });
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: true,
            message: 'File status updated successfully'
        });
    } catch (error) {
        console.error('Error updating file status:', error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: false,
            error: 'Failed to update file status'
        }, {
            status: 500
        });
    }
}
async function DELETE(request) {
    try {
        // Verify admin authentication
        const admin = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$admin$2d$app$2f$src$2f$lib$2f$admin$2d$auth$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["verifyAdminAuth"])();
        if (!admin) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                success: false,
                error: 'Unauthorized'
            }, {
                status: 401
            });
        }
        const { fileId, fileIds } = await request.json();
        const idsToDelete = Array.isArray(fileIds) ? fileIds.filter(Boolean) : fileId ? [
            fileId
        ] : [];
        if (!idsToDelete.length) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                success: false,
                error: 'File ID(s) are required'
            }, {
                status: 400
            });
        }
        // Batch delete (limit 500 per batch)
        let deletedCount = 0;
        const chunks = [];
        for(let i = 0; i < idsToDelete.length; i += 500){
            chunks.push(idsToDelete.slice(i, i + 500));
        }
        for (const chunk of chunks){
            const batch = __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$admin$2d$app$2f$src$2f$lib$2f$firebase$2d$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["adminDb"].batch();
            const fileDocs = await Promise.all(chunk.map((id)=>__TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$admin$2d$app$2f$src$2f$lib$2f$firebase$2d$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["adminDb"].collection('files').doc(id).get()));
            fileDocs.forEach((doc, idx)=>{
                if (doc.exists) {
                    const id = chunk[idx];
                    batch.delete(doc.ref);
                    // Log each deletion
                    const data = doc.data();
                    const logRef = __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$admin$2d$app$2f$src$2f$lib$2f$firebase$2d$admin$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["adminDb"].collection('logs').doc();
                    batch.set(logRef, {
                        action: 'file_deleted',
                        adminId: admin.adminId,
                        adminName: admin.name,
                        fileId: id,
                        fileName: data?.filename || 'Unknown',
                        originalName: data?.originalName || 'Unknown',
                        userId: data?.userId || 'Unknown',
                        timestamp: new Date()
                    });
                    deletedCount += 1;
                }
            });
            await batch.commit();
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$admin$2d$app$2f$src$2f$lib$2f$server$2d$cache$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["serverCache"].deleteByPrefix((0, __TURBOPACK__imported__module__$5b$project$5d2f$apps$2f$admin$2d$app$2f$src$2f$lib$2f$server$2d$cache$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["makeKey"])('files'));
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: true,
            message: deletedCount === 1 ? 'File deleted successfully' : `Deleted ${deletedCount} files`,
            deletedCount
        });
    } catch (error) {
        console.error('Error deleting file:', error);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            success: false,
            error: 'Failed to delete file'
        }, {
            status: 500
        });
    }
}
__turbopack_async_result__();
} catch(e) { __turbopack_async_result__(e); } }, false);}),
];

//# sourceMappingURL=%5Broot-of-the-server%5D__73da07fb._.js.map