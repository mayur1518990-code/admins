{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 91, "column": 0}, "map": {"version":3,"sources":["file:///D:/majalgav/hosting%20admin/apps/admin-app/src/lib/firebase-admin.ts"],"sourcesContent":["import { initializeApp, getApps, cert } from 'firebase-admin/app';\nimport { getAuth } from 'firebase-admin/auth';\nimport { getFirestore } from 'firebase-admin/firestore';\nimport { getStorage } from 'firebase-admin/storage';\n\n// Initialize Firebase Admin\nconst privateKey = process.env.FIREBASE_PRIVATE_KEY?.replace(/^\"|\"$/g, '') || '';\n\nconst firebaseAdminConfig = {\n  credential: cert({\n    projectId: process.env.FIREBASE_PROJECT_ID,\n    clientEmail: process.env.FIREBASE_CLIENT_EMAIL,\n    privateKey: privateKey,\n  }),\n};\n\n// Initialize Firebase Admin\nconst adminApp = getApps().length === 0 ? initializeApp(firebaseAdminConfig) : getApps()[0];\n\n// Initialize Firebase Admin services\nexport const adminAuth = getAuth(adminApp);\nexport const adminDb = getFirestore(adminApp);\nexport const adminStorage = getStorage(adminApp);\n\nexport default adminApp;\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;;;;;;;;;;;;AAEA,4BAA4B;AAC5B,MAAM,aAAa,QAAQ,GAAG,CAAC,oBAAoB,EAAE,QAAQ,UAAU,OAAO;AAE9E,MAAM,sBAAsB;IAC1B,YAAY,IAAA,wJAAI,EAAC;QACf,WAAW,QAAQ,GAAG,CAAC,mBAAmB;QAC1C,aAAa,QAAQ,GAAG,CAAC,qBAAqB;QAC9C,YAAY;IACd;AACF;AAEA,4BAA4B;AAC5B,MAAM,WAAW,IAAA,2JAAO,IAAG,MAAM,KAAK,IAAI,IAAA,iKAAa,EAAC,uBAAuB,IAAA,2JAAO,GAAE,CAAC,EAAE;AAGpF,MAAM,YAAY,IAAA,6JAAO,EAAC;AAC1B,MAAM,UAAU,IAAA,4KAAY,EAAC;AAC7B,MAAM,eAAe,IAAA,sKAAU,EAAC;uCAExB","debugId":null}},
    {"offset": {"line": 138, "column": 0}, "map": {"version":3,"sources":["file:///D:/majalgav/hosting%20admin/apps/admin-app/src/lib/get-default-agent.ts"],"sourcesContent":["import { adminDb } from './firebase-admin';\r\n\r\n/**\r\n * Get the first active agent from the database\r\n * This is used for development when we need to map to a real agent\r\n */\r\nexport async function getDefaultAgent() {\r\n  try {\r\n    const agentsSnapshot = await adminDb.collection('agents')\r\n      .where('isActive', '==', true)\r\n      .limit(1)\r\n      .get();\r\n\r\n    if (!agentsSnapshot.empty) {\r\n      const agentDoc = agentsSnapshot.docs[0];\r\n      const agentData = agentDoc.data();\r\n      \r\n      return {\r\n        agentId: agentDoc.id,\r\n        name: agentData.name || 'Unknown Agent',\r\n        email: agentData.email || 'unknown@example.com',\r\n        role: 'agent'\r\n      };\r\n    }\r\n\r\n    // Fallback to hardcoded values if no agents found\r\n    return {\r\n      agentId: \"bim290LXmEf6N7IuTzKU7bv5XcG2\",\r\n      name: \"Sunny Atul Dhore\", \r\n      email: \"dhoresunny5648@gmail.com\",\r\n      role: \"agent\"\r\n    };\r\n  } catch (error) {\r\n    console.error('Error getting default agent:', error);\r\n    // Fallback to hardcoded values\r\n    return {\r\n      agentId: \"bim290LXmEf6N7IuTzKU7bv5XcG2\",\r\n      name: \"Sunny Atul Dhore\",\r\n      email: \"dhoresunny5648@gmail.com\", \r\n      role: \"agent\"\r\n    };\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":";;;;AAAA;;;;;;AAMO,eAAe;IACpB,IAAI;QACF,MAAM,iBAAiB,MAAM,oKAAO,CAAC,UAAU,CAAC,UAC7C,KAAK,CAAC,YAAY,MAAM,MACxB,KAAK,CAAC,GACN,GAAG;QAEN,IAAI,CAAC,eAAe,KAAK,EAAE;YACzB,MAAM,WAAW,eAAe,IAAI,CAAC,EAAE;YACvC,MAAM,YAAY,SAAS,IAAI;YAE/B,OAAO;gBACL,SAAS,SAAS,EAAE;gBACpB,MAAM,UAAU,IAAI,IAAI;gBACxB,OAAO,UAAU,KAAK,IAAI;gBAC1B,MAAM;YACR;QACF;QAEA,kDAAkD;QAClD,OAAO;YACL,SAAS;YACT,MAAM;YACN,OAAO;YACP,MAAM;QACR;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,gCAAgC;QAC9C,+BAA+B;QAC/B,OAAO;YACL,SAAS;YACT,MAAM;YACN,OAAO;YACP,MAAM;QACR;IACF;AACF","debugId":null}},
    {"offset": {"line": 186, "column": 0}, "map": {"version":3,"sources":["file:///D:/majalgav/hosting%20admin/apps/admin-app/src/lib/agent-auth.ts"],"sourcesContent":["import { NextRequest } from \"next/server\";\nimport { cookies } from \"next/headers\";\nimport { adminAuth, adminDb } from \"./firebase-admin\";\nimport { getDefaultAgent } from \"./get-default-agent\";\n\n// Agent authentication helper that verifies against agents collection\n// OPTIMIZED: Removed expensive fallback to getDefaultAgent on every error\nexport async function verifyAgentAuth() {\n  try {\n    const cookieStore = await cookies();\n    const token = cookieStore.get('agent-token')?.value;\n    \n    // For development, we'll allow access with a simple token check\n    if (token === 'dev_agent_token') {\n      // Get the first active agent from the database\n      const defaultAgent = await getDefaultAgent();\n      return defaultAgent;\n    }\n\n    if (!token) {\n      throw new Error('No agent authentication token found');\n    }\n\n    // FIXED: Use verifySessionCookie or decode the token without verification\n    // Since we create custom tokens on the server, we can decode them without verification\n    try {\n      \n      // Try to verify as ID token first (for Firebase Auth tokens)\n      const decodedToken = await adminAuth.verifyIdToken(token).catch(async (err) => {\n        // If it fails because it's a custom token, decode it without verification\n        // Custom tokens are JWTs we created ourselves, so we can trust them\n        if (err.code === 'auth/argument-error') {\n          \n          // Decode JWT without verification (we created it, so it's safe)\n          const parts = token.split('.');\n          if (parts.length === 3) {\n            const payload = JSON.parse(Buffer.from(parts[1], 'base64').toString());\n            return payload.claims || payload;\n          }\n        }\n        throw err;\n      });\n      \n      // Check if this is a custom token with agent role\n      if (decodedToken.role === 'agent') {\n        return {\n          agentId: decodedToken.agentId || decodedToken.uid,\n          name: decodedToken.name || 'Agent',\n          email: decodedToken.email || 'agent@example.com',\n          role: \"agent\"\n        };\n      }\n      \n      // Get agent data from agents collection\n      const agentDoc = await adminDb.collection('agents').doc(decodedToken.uid).get();\n      \n      if (!agentDoc.exists) {\n        throw new Error('Agent not found in database');\n      }\n\n      const agentData = agentDoc.data();\n      \n      if (!agentData?.isActive) {\n        throw new Error('Agent account is deactivated');\n      }\n\n      return {\n        agentId: decodedToken.uid,\n        name: agentData.name,\n        email: agentData.email,\n        role: \"agent\"\n      };\n    } catch (tokenError) {\n      console.error('[AUTH] Token verification failed:', tokenError);\n      throw tokenError;\n    }\n  } catch (error) {\n    // OPTIMIZATION: Only use fallback in dev environment, not production\n    if (process.env.NODE_ENV === 'development') {\n      \n      const defaultAgent = await getDefaultAgent();\n      return defaultAgent;\n    }\n    // In production, throw error instead of expensive fallback\n    throw error;\n  }\n}\n\n// Helper function to get query parameters\nexport function getQueryParams(request: NextRequest) {\n  const { searchParams } = new URL(request.url);\n  return {\n    filter: searchParams.get('filter') || 'all',\n    dateFilter: searchParams.get('dateFilter') || 'all',\n    search: searchParams.get('search') || '',\n    limit: parseInt(searchParams.get('limit') || '50'),\n    offset: parseInt(searchParams.get('offset') || '0'),\n    status: searchParams.get('status'),\n    userId: searchParams.get('userId'),\n    fileId: searchParams.get('fileId'),\n    startDate: searchParams.get('startDate'),\n    endDate: searchParams.get('endDate')\n  };\n}"],"names":[],"mappings":";;;;;;AACA;AACA;AACA;;;;;;;;;AAIO,eAAe;IACpB,IAAI;QACF,MAAM,cAAc,MAAM,IAAA,4IAAO;QACjC,MAAM,QAAQ,YAAY,GAAG,CAAC,gBAAgB;QAE9C,gEAAgE;QAChE,IAAI,UAAU,mBAAmB;YAC/B,+CAA+C;YAC/C,MAAM,eAAe,MAAM,IAAA,kLAAe;YAC1C,OAAO;QACT;QAEA,IAAI,CAAC,OAAO;YACV,MAAM,IAAI,MAAM;QAClB;QAEA,0EAA0E;QAC1E,uFAAuF;QACvF,IAAI;YAEF,6DAA6D;YAC7D,MAAM,eAAe,MAAM,sKAAS,CAAC,aAAa,CAAC,OAAO,KAAK,CAAC,OAAO;gBACrE,0EAA0E;gBAC1E,oEAAoE;gBACpE,IAAI,IAAI,IAAI,KAAK,uBAAuB;oBAEtC,gEAAgE;oBAChE,MAAM,QAAQ,MAAM,KAAK,CAAC;oBAC1B,IAAI,MAAM,MAAM,KAAK,GAAG;wBACtB,MAAM,UAAU,KAAK,KAAK,CAAC,OAAO,IAAI,CAAC,KAAK,CAAC,EAAE,EAAE,UAAU,QAAQ;wBACnE,OAAO,QAAQ,MAAM,IAAI;oBAC3B;gBACF;gBACA,MAAM;YACR;YAEA,kDAAkD;YAClD,IAAI,aAAa,IAAI,KAAK,SAAS;gBACjC,OAAO;oBACL,SAAS,aAAa,OAAO,IAAI,aAAa,GAAG;oBACjD,MAAM,aAAa,IAAI,IAAI;oBAC3B,OAAO,aAAa,KAAK,IAAI;oBAC7B,MAAM;gBACR;YACF;YAEA,wCAAwC;YACxC,MAAM,WAAW,MAAM,oKAAO,CAAC,UAAU,CAAC,UAAU,GAAG,CAAC,aAAa,GAAG,EAAE,GAAG;YAE7E,IAAI,CAAC,SAAS,MAAM,EAAE;gBACpB,MAAM,IAAI,MAAM;YAClB;YAEA,MAAM,YAAY,SAAS,IAAI;YAE/B,IAAI,CAAC,WAAW,UAAU;gBACxB,MAAM,IAAI,MAAM;YAClB;YAEA,OAAO;gBACL,SAAS,aAAa,GAAG;gBACzB,MAAM,UAAU,IAAI;gBACpB,OAAO,UAAU,KAAK;gBACtB,MAAM;YACR;QACF,EAAE,OAAO,YAAY;YACnB,QAAQ,KAAK,CAAC,qCAAqC;YACnD,MAAM;QACR;IACF,EAAE,OAAO,OAAO;QACd,qEAAqE;QACrE,wCAA4C;YAE1C,MAAM,eAAe,MAAM,IAAA,kLAAe;YAC1C,OAAO;QACT;;;IAGF;AACF;AAGO,SAAS,eAAe,OAAoB;IACjD,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,QAAQ,GAAG;IAC5C,OAAO;QACL,QAAQ,aAAa,GAAG,CAAC,aAAa;QACtC,YAAY,aAAa,GAAG,CAAC,iBAAiB;QAC9C,QAAQ,aAAa,GAAG,CAAC,aAAa;QACtC,OAAO,SAAS,aAAa,GAAG,CAAC,YAAY;QAC7C,QAAQ,SAAS,aAAa,GAAG,CAAC,aAAa;QAC/C,QAAQ,aAAa,GAAG,CAAC;QACzB,QAAQ,aAAa,GAAG,CAAC;QACzB,QAAQ,aAAa,GAAG,CAAC;QACzB,WAAW,aAAa,GAAG,CAAC;QAC5B,SAAS,aAAa,GAAG,CAAC;IAC5B;AACF","debugId":null}},
    {"offset": {"line": 291, "column": 0}, "map": {"version":3,"sources":["file:///D:/majalgav/hosting%20admin/apps/admin-app/src/lib/cache.ts"],"sourcesContent":["type CacheEntry<T> = { data: T; timestamp: number };\n\nconst memoryCache = new Map<string, CacheEntry<any>>();\n\nexport function getCached<T>(key: string): CacheEntry<T> | undefined {\n  return memoryCache.get(key);\n}\n\nexport function setCached<T>(key: string, data: T): void {\n  memoryCache.set(key, { data, timestamp: Date.now() });\n}\n\nexport function getCacheKey(parts: Array<string | number | boolean | null | undefined>): string {\n  return parts.filter((p) => p !== undefined && p !== null).join(\":\");\n}\n\nexport function isFresh(entry: CacheEntry<any> | undefined, ttlMs: number): boolean {\n  if (!entry) return false;\n  return Date.now() - entry.timestamp < ttlMs;\n}\n\nexport function deleteCached(key: string): void {\n  memoryCache.delete(key);\n}\n\n\n"],"names":[],"mappings":";;;;;;;;;;;;AAEA,MAAM,cAAc,IAAI;AAEjB,SAAS,UAAa,GAAW;IACtC,OAAO,YAAY,GAAG,CAAC;AACzB;AAEO,SAAS,UAAa,GAAW,EAAE,IAAO;IAC/C,YAAY,GAAG,CAAC,KAAK;QAAE;QAAM,WAAW,KAAK,GAAG;IAAG;AACrD;AAEO,SAAS,YAAY,KAA0D;IACpF,OAAO,MAAM,MAAM,CAAC,CAAC,IAAM,MAAM,aAAa,MAAM,MAAM,IAAI,CAAC;AACjE;AAEO,SAAS,QAAQ,KAAkC,EAAE,KAAa;IACvE,IAAI,CAAC,OAAO,OAAO;IACnB,OAAO,KAAK,GAAG,KAAK,MAAM,SAAS,GAAG;AACxC;AAEO,SAAS,aAAa,GAAW;IACtC,YAAY,MAAM,CAAC;AACrB","debugId":null}},
    {"offset": {"line": 329, "column": 0}, "map": {"version":3,"sources":["file:///D:/majalgav/hosting%20admin/apps/admin-app/src/app/api/agent/files/%5BfileId%5D/status/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { adminDb } from '@/lib/firebase-admin';\nimport { verifyAgentAuth } from '@/lib/agent-auth';\nimport { deleteCached, getCacheKey } from '@/lib/cache';\nimport { serverCache, makeKey } from '@/lib/server-cache';\n\nexport async function PATCH(\n  request: NextRequest,\n  { params }: { params: Promise<{ fileId: string }> }\n) {\n  try {\n    // Verify agent authentication\n    const agent = await verifyAgentAuth();\n    if (!agent) {\n      return NextResponse.json({ success: false, error: 'Unauthorized' }, { status: 401 });\n    }\n\n    const { fileId } = await params;\n    const { status } = await request.json();\n\n    if (!status || !['processing', 'completed'].includes(status)) {\n      return NextResponse.json({\n        success: false,\n        error: 'Invalid status. Must be \"processing\" or \"completed\"'\n      }, { status: 400 });\n    }\n\n    // Verify the file is assigned to this agent\n    const fileDoc = await adminDb.collection('files').doc(fileId).get();\n    \n    if (!fileDoc.exists) {\n      return NextResponse.json({\n        success: false,\n        error: 'File not found'\n      }, { status: 404 });\n    }\n\n    const fileData = fileDoc.data();\n    if (fileData?.assignedAgentId !== agent.agentId) {\n      return NextResponse.json({\n        success: false,\n        error: 'File not assigned to you'\n      }, { status: 403 });\n    }\n\n    // Update file status\n    const updateData: any = {\n      status,\n      updatedAt: new Date()\n    };\n\n    if (status === 'processing') {\n      updateData.processingStartedAt = new Date();\n    } else if (status === 'completed') {\n      updateData.completedAt = new Date();\n    }\n\n    // OPTIMIZATION: Parallel operations (update + log)\n    await Promise.all([\n      adminDb.collection('files').doc(fileId).update(updateData),\n      adminDb.collection('logs').add({\n        action: 'file_status_updated',\n        agentId: agent.agentId,\n        agentName: agent.name,\n        fileId,\n        oldStatus: fileData.status,\n        newStatus: status,\n        timestamp: new Date()\n      })\n    ]);\n\n    // Invalidate user-app cache for this user's files so processing reflects quickly\n    if (fileData?.userId) {\n      const cacheKey = getCacheKey(['user_files', fileData.userId]);\n      deleteCached(cacheKey);\n    }\n\n    // NOTE: No server-side cache invalidation for status updates\n    // We use optimistic updates on the frontend instead of full refresh\n\n    return NextResponse.json({\n      success: true,\n      message: `File status updated to ${status}`,\n      status\n    });\n\n  } catch (error: any) {\n    console.error('Error updating file status:', error);\n    return NextResponse.json(\n      { success: false, error: 'Failed to update file status' },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;;;;;;AAGO,eAAe,MACpB,OAAoB,EACpB,EAAE,MAAM,EAA2C;IAEnD,IAAI;QACF,8BAA8B;QAC9B,MAAM,QAAQ,MAAM,IAAA,wKAAe;QACnC,IAAI,CAAC,OAAO;YACV,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,SAAS;gBAAO,OAAO;YAAe,GAAG;gBAAE,QAAQ;YAAI;QACpF;QAEA,MAAM,EAAE,MAAM,EAAE,GAAG,MAAM;QACzB,MAAM,EAAE,MAAM,EAAE,GAAG,MAAM,QAAQ,IAAI;QAErC,IAAI,CAAC,UAAU,CAAC;YAAC;YAAc;SAAY,CAAC,QAAQ,CAAC,SAAS;YAC5D,OAAO,gJAAY,CAAC,IAAI,CAAC;gBACvB,SAAS;gBACT,OAAO;YACT,GAAG;gBAAE,QAAQ;YAAI;QACnB;QAEA,4CAA4C;QAC5C,MAAM,UAAU,MAAM,oKAAO,CAAC,UAAU,CAAC,SAAS,GAAG,CAAC,QAAQ,GAAG;QAEjE,IAAI,CAAC,QAAQ,MAAM,EAAE;YACnB,OAAO,gJAAY,CAAC,IAAI,CAAC;gBACvB,SAAS;gBACT,OAAO;YACT,GAAG;gBAAE,QAAQ;YAAI;QACnB;QAEA,MAAM,WAAW,QAAQ,IAAI;QAC7B,IAAI,UAAU,oBAAoB,MAAM,OAAO,EAAE;YAC/C,OAAO,gJAAY,CAAC,IAAI,CAAC;gBACvB,SAAS;gBACT,OAAO;YACT,GAAG;gBAAE,QAAQ;YAAI;QACnB;QAEA,qBAAqB;QACrB,MAAM,aAAkB;YACtB;YACA,WAAW,IAAI;QACjB;QAEA,IAAI,WAAW,cAAc;YAC3B,WAAW,mBAAmB,GAAG,IAAI;QACvC,OAAO,IAAI,WAAW,aAAa;YACjC,WAAW,WAAW,GAAG,IAAI;QAC/B;QAEA,mDAAmD;QACnD,MAAM,QAAQ,GAAG,CAAC;YAChB,oKAAO,CAAC,UAAU,CAAC,SAAS,GAAG,CAAC,QAAQ,MAAM,CAAC;YAC/C,oKAAO,CAAC,UAAU,CAAC,QAAQ,GAAG,CAAC;gBAC7B,QAAQ;gBACR,SAAS,MAAM,OAAO;gBACtB,WAAW,MAAM,IAAI;gBACrB;gBACA,WAAW,SAAS,MAAM;gBAC1B,WAAW;gBACX,WAAW,IAAI;YACjB;SACD;QAED,iFAAiF;QACjF,IAAI,UAAU,QAAQ;YACpB,MAAM,WAAW,IAAA,4JAAW,EAAC;gBAAC;gBAAc,SAAS,MAAM;aAAC;YAC5D,IAAA,6JAAY,EAAC;QACf;QAEA,6DAA6D;QAC7D,oEAAoE;QAEpE,OAAO,gJAAY,CAAC,IAAI,CAAC;YACvB,SAAS;YACT,SAAS,CAAC,uBAAuB,EAAE,QAAQ;YAC3C;QACF;IAEF,EAAE,OAAO,OAAY;QACnB,QAAQ,KAAK,CAAC,+BAA+B;QAC7C,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,SAAS;YAAO,OAAO;QAA+B,GACxD;YAAE,QAAQ;QAAI;IAElB;AACF","debugId":null}}]
}