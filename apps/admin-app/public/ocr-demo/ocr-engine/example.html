<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>OCR Workspace</title>
  <style>
    body {
      font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #f3f4f6;
      color: #1f2937;
      margin: 0;
      min-height: 100vh;
    }

    .page {
      max-width: 1200px;
      margin: 0 auto;
      padding: 40px 24px 64px;
      display: flex;
      flex-direction: column;
      gap: 24px;
    }

    .top-bar {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 16px;
    }

    .top-bar h1 {
      margin: 0;
      font-size: 2rem;
      font-weight: 700;
      color: #0f172a;
    }

    .top-bar p {
      margin: 8px 0 0;
      color: #4b5563;
      font-size: 1rem;
      max-width: 720px;
    }

    .back-link {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 10px 16px;
      border-radius: 999px;
      background: #1f2937;
      color: #ffffff;
      font-weight: 500;
      text-decoration: none;
      transition: background 0.2s ease, transform 0.15s ease;
      white-space: nowrap;
    }

    .back-link:hover {
      background: #111827;
      transform: translateY(-1px);
    }

    .layout {
      display: grid;
      grid-template-columns: minmax(320px, 420px) minmax(0, 1fr);
      gap: 24px;
      align-items: start;
    }

    .controls-card {
      position: sticky;
      top: 24px;
      z-index: 3;
    }

    .card {
      background: #ffffff;
      border-radius: 16px;
      padding: 24px;
      box-shadow: 0 10px 30px -20px rgba(15, 23, 42, 0.3);
      border: 1px solid #e5e7eb;
    }

    .card h2 {
      margin: 0 0 12px;
      font-size: 1.1rem;
      font-weight: 600;
      color: #0f172a;
    }

    .card p {
      margin: 0 0 16px;
      font-size: 0.95rem;
      color: #4b5563;
      line-height: 1.5;
    }

    input[type="file"] {
      width: 100%;
      margin-top: 12px;
    }

    .button-row {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-top: 16px;
    }

    button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 10px 18px;
      border-radius: 10px;
      font-size: 0.95rem;
      font-weight: 500;
      border: none;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.2s ease;
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    button.primary {
      background: #2563eb;
      color: #ffffff;
      box-shadow: 0 10px 20px -12px rgba(37, 99, 235, 0.6);
    }

    button.primary:hover:not(:disabled) {
      background: #1d4ed8;
      transform: translateY(-1px);
    }

    button.secondary {
      background: #f1f5f9;
      color: #1f2937;
    }

    button.secondary:hover:not(:disabled) {
      background: #e2e8f0;
      transform: translateY(-1px);
    }

    button.ghost {
      background: transparent;
      color: #2563eb;
      border: 1px solid #bfdbfe;
    }

    button.ghost:hover:not(:disabled) {
      background: #eff6ff;
    }

    .page-picker,
    .field-group {
      margin-top: 16px;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .page-picker label,
    .field-group label {
      font-size: 0.85rem;
      font-weight: 500;
      color: #475569;
    }

    .page-picker select,
    .field-group select {
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid #cbd5f5;
      font-size: 0.95rem;
      color: #1f2937;
      background: #fff;
    }

    .page-picker[hidden] {
      display: none !important;
    }

    .status-row {
      font-size: 0.9rem;
      color: #475569;
      min-height: 20px;
      margin-top: 16px;
    }

    .result-inline {
      margin-top: 8px;
      padding: 16px;
      background: #f8fafc;
      border-radius: 12px;
      border: 1px dashed #cbd5f5;
      min-height: 120px;
      max-height: 400px;
      overflow-y: auto;
      overflow-x: hidden;
      word-break: break-word;
    }

    .preview-wrapper {
      position: relative;
      background: #f8fafc;
      border-radius: 12px;
      border: 1px dashed #dbeafe;
      min-height: 260px;
      display: flex;
      align-items: flex-start;
      justify-content: center;
      overflow-x: hidden;
      overflow-y: auto;
      padding: 24px;
      scroll-behavior: smooth;
    }

    .preview-wrapper.large {
      min-height: 520px;
    }

    .preview-placeholder {
      text-align: center;
      color: #64748b;
      font-size: 0.95rem;
      padding: 48px 16px;
      width: 100%;
    }

    .page-stack {
      display: flex;
      flex-direction: column;
      gap: 32px;
      width: 100%;
    }

    .page-stack img {
      max-width: 100%;
      max-height: 900px;
      object-fit: contain;
      border-radius: 12px;
      box-shadow: 0 20px 40px -32px rgba(15, 23, 42, 0.4);
    }

    .selection-meta {
      margin-top: 16px;
      font-size: 0.9rem;
      color: #0f172a;
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .selection-meta strong {
      font-weight: 600;
    }

    @media (max-width: 768px) {
      .page {
        padding: 32px 16px 56px;
      }

      .top-bar {
        flex-direction: column;
        align-items: flex-start;
      }

      .layout {
        grid-template-columns: 1fr;
      }

      .controls-card {
        position: static;
      }

      .preview-wrapper.large {
        min-height: 360px;
        padding: 16px;
      }

      .page-stack img {
        max-height: 640px;
      }
    }
  </style>
  <link rel="stylesheet" href="./ui/inject.css">
</head>
<body>
  <div class="page">
    <header class="top-bar">
      <div>
        <h1>OCR Workspace</h1>
        <p>Upload an image or PDF, or capture regions directly from this page. You can collect multiple selections without losing the full document preview.</p>
      </div>
      <a href="/agent" class="back-link" id="backLink">← Back to Agent Dashboard</a>
    </header>

    <main class="layout">
      <section class="card controls-card">
        <h2>Document Source</h2>
        <p>Upload an image or PDF to begin. The preview on the right shows every page; you can draw multiple regions without replacing the original preview.</p>
        <input type="file" id="imageInput" accept="image/*,application/pdf,.pdf">
        <div class="button-row">
          <button class="primary" id="processBtn" disabled>Process Selection</button>
          <button class="secondary" id="select-area">Select Area</button>
          <button class="ghost" id="useFullDocument" disabled>Use Full Document</button>
        </div>
        <div class="field-group">
          <label for="languageSelect">Recognition language</label>
          <select id="languageSelect">
            <option value="eng" selected>English (eng)</option>
            <option value="ara">Arabic (ara)</option>
            <option value="ben">Bengali (ben)</option>
            <option value="chi_sim">Chinese Simplified (chi_sim)</option>
            <option value="fra">French (fra)</option>
            <option value="deu">German (deu)</option>
            <option value="hin">Hindi (hin)</option>
            <option value="ita">Italian (ita)</option>
            <option value="jpn">Japanese (jpn)</option>
            <option value="kor">Korean (kor)</option>
            <option value="mar">Marathi (mar)</option>
            <option value="por">Portuguese (por)</option>
            <option value="rus">Russian (rus)</option>
            <option value="spa">Spanish (spa)</option>
            <option value="tam">Tamil (tam)</option>
            <option value="tel">Telugu (tel)</option>
          </select>
        </div>
        <div class="field-group" style="margin-top: 12px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
            <input type="checkbox" id="removeBorders" checked style="width: auto; margin: 0;">
            <span>Remove borders/lines (improves OCR accuracy)</span>
          </label>
        </div>
        <div class="page-picker" id="pagePickerRow" hidden>
          <label for="pagePicker">Page to process when using full document</label>
          <select id="pagePicker"></select>
        </div>
        <div class="selection-meta">
          <span>Active source:</span>
          <strong id="selectionStatus">No document loaded</strong>
        </div>
        <div class="status-row" id="progress"></div>
        <div id="result" class="result-inline"></div>
      </section>

      <section class="card preview-card">
        <h2>Full Preview</h2>
        <p>Scroll to view every page that was detected. All selections operate on the live view below.</p>
        <div class="preview-wrapper large" id="fullPreviewWrapper">
          <div class="preview-placeholder" id="previewPlaceholder">
            Upload an image or PDF to see the preview here.
          </div>
          <div id="fullPreviewStack" class="page-stack"></div>
        </div>
      </section>
    </main>
  </div>

  <div id="ocr-frame-container" style="position:fixed;bottom:10px;right:10px;width:500px;z-index:2147483647;display:none;background:#ffffff;border-radius:8px;box-shadow:0 4px 20px rgba(0,0,0,0.3);border:1px solid #e5e7eb;">
    <div id="ocr-frame-header" style="background:#2563eb;color:#ffffff;padding:8px 12px;cursor:move;border-radius:8px 8px 0 0;user-select:none;font-size:0.875rem;font-weight:500;display:flex;justify-content:space-between;align-items:center;">
      <span>OCR Preview</span>
      <button id="ocr-frame-close" style="background:transparent;border:none;color:#ffffff;cursor:pointer;font-size:1.2rem;line-height:1;padding:0;width:20px;height:20px;display:flex;align-items:center;justify-content:center;">×</button>
    </div>
    <iframe id="ocr-frame"
            src="./ui/sandbox.html"
            style="width:100%;height:320px;border:none;display:block;border-radius:0 0 8px 8px;">
    </iframe>
  </div>

  <script src="storage.js"></script>
  <script src="ocr.js"></script>
  <script src="https://unpkg.com/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
  <script>
    const ocr = new OCRLibrary({
      enginePath: './engine',
      defaultLang: 'eng',
      defaultAccuracy: '4.0.0'
    });

    const imageInput = document.getElementById('imageInput');
    const processBtn = document.getElementById('processBtn');
    const selectBtn = document.getElementById('select-area');
    const useFullDocumentBtn = document.getElementById('useFullDocument');
    const progressDiv = document.getElementById('progress');
    const resultDiv = document.getElementById('result');
    const selectionStatus = document.getElementById('selectionStatus');
    const previewPlaceholder = document.getElementById('previewPlaceholder');
    const fullPreviewStack = document.getElementById('fullPreviewStack');
    const fullPreviewWrapper = document.getElementById('fullPreviewWrapper');
    const pagePickerRow = document.getElementById('pagePickerRow');
    const pagePicker = document.getElementById('pagePicker');
    const languageSelect = document.getElementById('languageSelect');
    const removeBordersCheckbox = document.getElementById('removeBorders');
    const ocrFrameContainer = document.getElementById('ocr-frame-container');
    const ocrFrame = document.getElementById('ocr-frame');
    const ocrFrameHeader = document.getElementById('ocr-frame-header');
    const ocrFrameClose = document.getElementById('ocr-frame-close');

    let currentImageData = null;
    let originalImageData = null;
    let pdfPageImages = [];
    let activePageIndex = 0;
    let selectionCount = 0;
    let selectionScriptLoaded = false;
    let hasActiveSelection = false;
    let lastSelectionLabel = '';
    let selectedLanguage = languageSelect.value || 'eng';

    function updateSelectionStatus(text) {
      selectionStatus.textContent = text;
    }

    function updateProcessButtonLabel() {
      if (!currentImageData) {
        processBtn.textContent = 'Process Selection';
        processBtn.disabled = true;
        return;
      }

      if (hasActiveSelection) {
        processBtn.textContent = 'Process ' + (lastSelectionLabel || 'Selection');
      } else if (pdfPageImages.length > 1) {
        processBtn.textContent = 'Process Page ' + (activePageIndex + 1);
      } else {
        processBtn.textContent = 'Process Full Document';
      }
    }

    function showFullPreview(images, altTextBase) {
      fullPreviewStack.innerHTML = '';

      if (images && images.length) {
        images.forEach((src, index) => {
          const img = document.createElement('img');
          img.src = src;
          img.alt = (altTextBase || 'Document preview') + ' – Page ' + (index + 1);
          fullPreviewStack.appendChild(img);
        });
        previewPlaceholder.style.display = 'none';
        fullPreviewWrapper.classList.add('has-content');
      } else {
        previewPlaceholder.style.display = 'block';
        fullPreviewWrapper.classList.remove('has-content');
      }
    }

    function configurePagePicker() {
      if (pdfPageImages.length <= 1) {
        pagePickerRow.hidden = true;
        pagePicker.innerHTML = '';
        return;
      }

      pagePicker.innerHTML = pdfPageImages
        .map((_, index) => '<option value="' + index + '">Page ' + (index + 1) + '</option>')
        .join('');
      pagePicker.value = String(activePageIndex);
      pagePickerRow.hidden = false;
      pagePicker.disabled = false;
    }

    function resetWorkspace() {
      currentImageData = null;
      originalImageData = null;
      pdfPageImages = [];
      activePageIndex = 0;
      selectionCount = 0;
      hasActiveSelection = false;
      lastSelectionLabel = '';
      showFullPreview(null);
      configurePagePicker();
      updateSelectionStatus('No document loaded');
      resultDiv.innerHTML = '';
      progressDiv.textContent = '';
      updateProcessButtonLabel();
      processBtn.disabled = true;
      useFullDocumentBtn.disabled = true;
    }

    function handleNewSelection(dataUrl) {
      selectionCount += 1;
      const label = 'Selection ' + selectionCount;
      currentImageData = dataUrl;
      hasActiveSelection = true;
      lastSelectionLabel = label;
      updateSelectionStatus(label + ' (cropped area)');
      updateProcessButtonLabel();
      processBtn.disabled = false;
      useFullDocumentBtn.disabled = pdfPageImages.length === 0 && !originalImageData;
      progressDiv.textContent = label + ' captured. Click "Process ' + label + '" to run OCR or capture another area.';
    }

    resetWorkspace();

    // Image preprocessing to remove borders/lines and enhance text
    async function preprocessImage(imageDataUrl) {
      return new Promise((resolve) => {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          canvas.width = img.width;
          canvas.height = img.height;
          ctx.drawImage(img, 0, 0);

          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          const data = imageData.data;
          const width = imageData.width;
          const height = imageData.height;

          // Convert to grayscale and enhance contrast
          for (let i = 0; i < data.length; i += 4) {
            const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
            // Enhance contrast (make dark pixels darker, light pixels lighter)
            const enhanced = gray < 128 ? gray * 0.7 : Math.min(255, gray * 1.3);
            data[i] = enhanced;
            data[i + 1] = enhanced;
            data[i + 2] = enhanced;
          }

          // Detect and remove horizontal lines
          const horizontalLineThreshold = width * 0.6; // Line must span at least 60% of width
          for (let y = 1; y < height - 1; y++) {
            let darkPixels = 0;
            for (let x = 0; x < width; x++) {
              const idx = (y * width + x) * 4;
              if (data[idx] < 100) darkPixels++; // Count dark pixels
            }
            if (darkPixels > horizontalLineThreshold) {
              // This row is likely a horizontal line, make it white
              for (let x = 0; x < width; x++) {
                const idx = (y * width + x) * 4;
                data[idx] = 255;
                data[idx + 1] = 255;
                data[idx + 2] = 255;
              }
            }
          }

          // Detect and remove vertical lines
          const verticalLineThreshold = height * 0.6; // Line must span at least 60% of height
          for (let x = 1; x < width - 1; x++) {
            let darkPixels = 0;
            for (let y = 0; y < height; y++) {
              const idx = (y * width + x) * 4;
              if (data[idx] < 100) darkPixels++; // Count dark pixels
            }
            if (darkPixels > verticalLineThreshold) {
              // This column is likely a vertical line, make it white
              for (let y = 0; y < height; y++) {
                const idx = (y * width + x) * 4;
                data[idx] = 255;
                data[idx + 1] = 255;
                data[idx + 2] = 255;
              }
            }
          }

          // Apply the processed image data
          ctx.putImageData(imageData, 0, 0);
          resolve(canvas.toDataURL('image/png'));
        };
        img.onerror = () => resolve(imageDataUrl); // Fallback to original if processing fails
        img.src = imageDataUrl;
      });
    }

    const loadPdfJs = (() => {
      let loader = null;
      return () => {
        if (loader) {
          return loader;
        }
        loader = new Promise((resolve, reject) => {
          if (window.pdfjsLib) {
            resolve(window.pdfjsLib);
            return;
          }
          const script = document.createElement('script');
          script.src = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.9.179/pdf.min.js';
          script.onload = () => {
            if (window.pdfjsLib) {
              window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.9.179/pdf.worker.min.js';
              resolve(window.pdfjsLib);
            } else {
              reject(new Error('pdf.js failed to load'));
            }
          };
          script.onerror = () => reject(new Error('Unable to load pdf.js'));
          document.head.appendChild(script);
        });
        return loader;
      };
    })();

    async function renderPdfToImages(file) {
      const pdfjsLib = await loadPdfJs();
      const data = await file.arrayBuffer();
      const pdf = await pdfjsLib.getDocument({ data }).promise;
      const totalPages = pdf.numPages;
      const images = [];

      for (let pageNumber = 1; pageNumber <= totalPages; pageNumber += 1) {
        const page = await pdf.getPage(pageNumber);
        const viewport = page.getViewport({ scale: 1.5 });
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        const outputScale = window.devicePixelRatio || 1;
        canvas.width = viewport.width * outputScale;
        canvas.height = viewport.height * outputScale;
        canvas.style.width = viewport.width + 'px';
        canvas.style.height = viewport.height + 'px';
        await page.render({
          canvasContext: context,
          viewport,
          transform: outputScale !== 1 ? [outputScale, 0, 0, outputScale, 0, 0] : null
        }).promise;
        images.push(canvas.toDataURL('image/png'));
      }

      return images;
    }

    imageInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];

      if (!file) {
        resetWorkspace();
        return;
      }

      resultDiv.innerHTML = '';
      progressDiv.textContent = '';
      selectionCount = 0;
      hasActiveSelection = false;
      lastSelectionLabel = '';

      try {
        if (file.type === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf')) {
          progressDiv.textContent = 'Rendering PDF...';
          pdfPageImages = await renderPdfToImages(file);
          if (!pdfPageImages.length) {
            throw new Error('No pages found in PDF');
          }
          originalImageData = pdfPageImages[0];
          currentImageData = pdfPageImages[0];
          activePageIndex = 0;
          configurePagePicker();
          showFullPreview(pdfPageImages, 'Preview of ' + (file.name || 'document'));
          updateSelectionStatus('Page 1');
        } else {
          const reader = new FileReader();
          const imageData = await new Promise((resolve, reject) => {
            reader.onload = event => resolve(event.target.result);
            reader.onerror = () => reject(new Error('Failed to read file'));
            reader.readAsDataURL(file);
          });
          pdfPageImages = [];
          originalImageData = imageData;
          currentImageData = imageData;
          activePageIndex = 0;
          configurePagePicker();
          showFullPreview([imageData], 'Preview of ' + (file.name || 'document'));
          updateSelectionStatus('Full document');
        }

        updateProcessButtonLabel();
        processBtn.disabled = false;
        useFullDocumentBtn.disabled = false;
        progressDiv.textContent = pdfPageImages.length > 1
          ? 'PDF ready. Switch pages with the dropdown or capture regions directly from the preview.'
          : 'Document ready. Capture a region or process the full document.';
      } catch (err) {
        console.error('Failed to prepare file for OCR:', err);
        resetWorkspace();
        resultDiv.innerHTML = '<span style="color:red;">' + err.message + '</span>';
        progressDiv.textContent = 'Error preparing file';
      }
    });

    processBtn.addEventListener('click', async () => {
      if (!currentImageData) {
        return;
      }

      const activeLabel = hasActiveSelection
        ? (lastSelectionLabel || 'Selection')
        : (pdfPageImages.length > 1 ? 'Page ' + (activePageIndex + 1) : 'Full Document');

      progressDiv.textContent = 'Processing...';
      resultDiv.innerHTML = '';
      processBtn.disabled = true;
      processBtn.textContent = 'Processing...';

      try {
        let imageToProcess = currentImageData;
        
        // Apply preprocessing if enabled
        if (removeBordersCheckbox && removeBordersCheckbox.checked) {
          progressDiv.textContent = 'Removing borders and enhancing image...';
          imageToProcess = await preprocessImage(currentImageData);
        }
        
        const result = await ocr.recognize(imageToProcess, {
          lang: selectedLanguage,
          accuracy: '4.0.0',
          onProgress: (report) => {
            const percent = report.progress ? Math.round(report.progress * 100) : 0;
            progressDiv.textContent = (report.status || 'Processing') + '... ' + percent + '%';
          }
        });
        resultDiv.innerHTML = result.hocr || result.text;
        progressDiv.textContent = 'Done! (' + activeLabel + ') Confidence: ' + Math.round(result.confidence) + '%';
      } catch (error) {
        resultDiv.innerHTML = '<span style="color:red;">' + error.message + '</span>';
        progressDiv.textContent = 'Error occurred';
        console.error('OCR Error:', error);
      } finally {
        processBtn.disabled = !currentImageData;
        updateProcessButtonLabel();
      }
    });

    useFullDocumentBtn.addEventListener('click', () => {
      const baseImage = pdfPageImages.length ? pdfPageImages[activePageIndex] : originalImageData;
      if (!baseImage) {
        return;
      }
      hasActiveSelection = false;
      lastSelectionLabel = '';
      currentImageData = baseImage;
      updateSelectionStatus(pdfPageImages.length > 1 ? 'Page ' + (activePageIndex + 1) : 'Full document');
      updateProcessButtonLabel();
      processBtn.disabled = false;
      useFullDocumentBtn.disabled = false;
      progressDiv.textContent = 'Using the full page for OCR.';
    });

    function loadSelectionScript() {
      return new Promise(resolve => {
        const script = document.createElement('script');
        script.src = './ui/inject.js?_=' + Date.now();
        script.onload = resolve;
        document.documentElement.append(script);
      });
    }

    async function ensureSelectionScript() {
      if (!selectionScriptLoaded) {
        await loadSelectionScript();
        selectionScriptLoaded = true;
      } else if (window.capture && window.guide && window.monitor) {
        window.guide.install();
        window.capture.install();
        window.monitor.install();
      }
    }

    selectBtn.addEventListener('click', async () => {
      await ensureSelectionScript();
      progressDiv.textContent = 'Draw a rectangle over the area you want to capture.';
    });

    document.addEventListener('ocr-aborted', () => {
      ocrFrameContainer.style.display = 'none';
      progressDiv.textContent = 'Selection cancelled. Try again when ready.';
    });

    document.addEventListener('ocr-captured', async (event) => {
      const { left, top, width, height, devicePixelRatio } = event.detail;
      const dpr = devicePixelRatio || window.devicePixelRatio || 1;
      const clampedWidth = Math.max(1, Math.round(width));
      const clampedHeight = Math.max(1, Math.round(height));
      console.log('[OCR] Captured box', { left, top, width: clampedWidth, height: clampedHeight, dpr });

      if (!clampedWidth || !clampedHeight) {
        alert('Please drag an area with a non-zero width and height.');
        return;
      }

      try {
        const canvas = await html2canvas(document.body, {
          x: left + window.scrollX,
          y: top + window.scrollY,
          width: clampedWidth,
          height: clampedHeight,
          scale: dpr,
          backgroundColor: null,
          useCORS: true,
          allowTaint: true
        });
        let dataUrl = canvas.toDataURL('image/png');
        
        // Apply preprocessing if enabled
        if (removeBordersCheckbox && removeBordersCheckbox.checked) {
          progressDiv.textContent = 'Removing borders and enhancing image...';
          dataUrl = await preprocessImage(dataUrl);
        }
        
        handleNewSelection(dataUrl);

        // Show the OCR frame only after area selection is complete
        ocrFrameContainer.style.display = 'block';
        
        ocrFrame.contentWindow.postMessage({
          method: 'proceed',
          href: dataUrl,
          request: {
            left: 0,
            top: 0,
            width: clampedWidth,
            height: clampedHeight,
            devicePixelRatio: dpr
          }
        }, '*');
      } catch (error) {
        console.error('Failed to capture area for OCR:', error);
        progressDiv.textContent = 'Unable to capture that area. Please try again.';
      }
    });

    window.addEventListener('message', event => {
      const { method } = event.data || {};
      if (method === 'remove-iframe') {
        ocrFrameContainer.style.display = 'none';
      }
    });

    // Drag functionality for OCR frame
    let isDragging = false;
    let dragOffset = { x: 0, y: 0 };

    ocrFrameHeader.addEventListener('mousedown', (e) => {
      if (e.target === ocrFrameClose) return; // Don't drag when clicking close button
      isDragging = true;
      const rect = ocrFrameContainer.getBoundingClientRect();
      dragOffset.x = e.clientX - rect.left;
      dragOffset.y = e.clientY - rect.top;
      ocrFrameHeader.style.cursor = 'grabbing';
      e.preventDefault();
    });

    document.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      
      const maxX = window.innerWidth - ocrFrameContainer.offsetWidth;
      const maxY = window.innerHeight - ocrFrameContainer.offsetHeight;
      
      let newX = e.clientX - dragOffset.x;
      let newY = e.clientY - dragOffset.y;
      
      // Constrain to viewport
      newX = Math.max(0, Math.min(newX, maxX));
      newY = Math.max(0, Math.min(newY, maxY));
      
      ocrFrameContainer.style.left = newX + 'px';
      ocrFrameContainer.style.top = newY + 'px';
      ocrFrameContainer.style.right = 'auto';
      ocrFrameContainer.style.bottom = 'auto';
    });

    document.addEventListener('mouseup', () => {
      if (isDragging) {
        isDragging = false;
        ocrFrameHeader.style.cursor = 'move';
      }
    });

    // Close button functionality
    ocrFrameClose.addEventListener('click', () => {
      ocrFrameContainer.style.display = 'none';
    });

    pagePicker.addEventListener('change', (event) => {
      const nextIndex = parseInt(event.target.value, 10);
      if (Number.isNaN(nextIndex) || !pdfPageImages[nextIndex]) {
        return;
      }
      activePageIndex = nextIndex;
      if (!hasActiveSelection) {
        currentImageData = pdfPageImages[activePageIndex];
        updateSelectionStatus('Page ' + (activePageIndex + 1));
        updateProcessButtonLabel();
      }
    });

    languageSelect.addEventListener('change', (event) => {
      const value = event.target.value;
      selectedLanguage = value || 'eng';
      if (!hasActiveSelection && currentImageData) {
        progressDiv.textContent = 'Language set to ' + selectedLanguage + '. Ready to process.';
      }
    });
  </script>
</body>
</html>
