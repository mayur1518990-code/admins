{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 91, "column": 0}, "map": {"version":3,"sources":["file:///D:/majalgav/hosting%20admin/apps/admin-app/src/lib/firebase-admin.ts"],"sourcesContent":["import { initializeApp, getApps, cert } from 'firebase-admin/app';\nimport { getAuth } from 'firebase-admin/auth';\nimport { getFirestore } from 'firebase-admin/firestore';\nimport { getStorage } from 'firebase-admin/storage';\n\n// Initialize Firebase Admin\n// Handle both true multiline and \"\\n\"-escaped private keys\nconst privateKey = (process.env.FIREBASE_PRIVATE_KEY || '')\n  .replace(/^\"|\"$/g, '')\n  .replace(/\\\\n/g, '\\n');\n\nconst firebaseAdminConfig = {\n  credential: cert({\n    projectId: process.env.FIREBASE_PROJECT_ID,\n    clientEmail: process.env.FIREBASE_CLIENT_EMAIL,\n    privateKey: privateKey,\n  }),\n};\n\n// Initialize Firebase Admin\nconst adminApp = getApps().length === 0 ? initializeApp(firebaseAdminConfig) : getApps()[0];\n\n// Initialize Firebase Admin services\nexport const adminAuth = getAuth(adminApp);\nexport const adminDb = getFirestore(adminApp);\nexport const adminStorage = getStorage(adminApp);\n\nexport default adminApp;\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;;;;;;;;;;;;AAEA,4BAA4B;AAC5B,2DAA2D;AAC3D,MAAM,aAAa,CAAC,QAAQ,GAAG,CAAC,oBAAoB,IAAI,EAAE,EACvD,OAAO,CAAC,UAAU,IAClB,OAAO,CAAC,QAAQ;AAEnB,MAAM,sBAAsB;IAC1B,YAAY,IAAA,wJAAI,EAAC;QACf,WAAW,QAAQ,GAAG,CAAC,mBAAmB;QAC1C,aAAa,QAAQ,GAAG,CAAC,qBAAqB;QAC9C,YAAY;IACd;AACF;AAEA,4BAA4B;AAC5B,MAAM,WAAW,IAAA,2JAAO,IAAG,MAAM,KAAK,IAAI,IAAA,iKAAa,EAAC,uBAAuB,IAAA,2JAAO,GAAE,CAAC,EAAE;AAGpF,MAAM,YAAY,IAAA,6JAAO,EAAC;AAC1B,MAAM,UAAU,IAAA,4KAAY,EAAC;AAC7B,MAAM,eAAe,IAAA,sKAAU,EAAC;uCAExB","debugId":null}},
    {"offset": {"line": 137, "column": 0}, "map": {"version":3,"sources":["file:///D:/majalgav/hosting%20admin/apps/admin-app/src/lib/server-cache.ts"],"sourcesContent":["type CacheEntry<T> = { data: T; expiresAt: number };\r\n\r\nclass SimpleLRUCache {\r\n  private store = new Map<string, CacheEntry<any>>();\r\n  private order: string[] = [];\r\n  constructor(private maxEntries: number = 200) {}\r\n\r\n  get<T>(key: string): T | undefined {\r\n    const entry = this.store.get(key);\r\n    if (!entry) return undefined;\r\n    if (Date.now() > entry.expiresAt) {\r\n      this.delete(key);\r\n      return undefined;\r\n    }\r\n    // touch\r\n    this.order = this.order.filter(k => k !== key);\r\n    this.order.push(key);\r\n    return entry.data as T;\r\n    }\r\n\r\n  set<T>(key: string, value: T, ttlMs: number): void {\r\n    const expiresAt = Date.now() + ttlMs;\r\n    this.store.set(key, { data: value, expiresAt });\r\n    this.order = this.order.filter(k => k !== key);\r\n    this.order.push(key);\r\n    // evict\r\n    while (this.order.length > this.maxEntries) {\r\n      const oldest = this.order.shift();\r\n      if (oldest) this.store.delete(oldest);\r\n    }\r\n  }\r\n\r\n  delete(key: string): void {\r\n    this.store.delete(key);\r\n    this.order = this.order.filter(k => k !== key);\r\n  }\r\n\r\n  deleteByPrefix(prefix: string): void {\r\n    for (const key of Array.from(this.store.keys())) {\r\n      if (key.startsWith(prefix)) this.delete(key);\r\n    }\r\n  }\r\n}\r\n\r\nexport const serverCache = new SimpleLRUCache(300);\r\n\r\nexport function makeKey(resource: string, parts: Array<string | number | boolean | null | undefined> = []) {\r\n  return `admin:${resource}:${parts.filter(v => v !== undefined && v !== null).join(':')}`;\r\n}\r\n\r\n\r\n\r\n\r\n"],"names":[],"mappings":";;;;;;AAEA,MAAM;;IACI,MAA2C;IAC3C,MAAqB;IAC7B,YAAY,AAAQ,aAAqB,GAAG,CAAE;aAA1B,aAAA;aAFZ,QAAQ,IAAI;aACZ,QAAkB,EAAE;IACmB;IAE/C,IAAO,GAAW,EAAiB;QACjC,MAAM,QAAQ,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;QAC7B,IAAI,CAAC,OAAO,OAAO;QACnB,IAAI,KAAK,GAAG,KAAK,MAAM,SAAS,EAAE;YAChC,IAAI,CAAC,MAAM,CAAC;YACZ,OAAO;QACT;QACA,QAAQ;QACR,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAA,IAAK,MAAM;QAC1C,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;QAChB,OAAO,MAAM,IAAI;IACjB;IAEF,IAAO,GAAW,EAAE,KAAQ,EAAE,KAAa,EAAQ;QACjD,MAAM,YAAY,KAAK,GAAG,KAAK;QAC/B,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,KAAK;YAAE,MAAM;YAAO;QAAU;QAC7C,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAA,IAAK,MAAM;QAC1C,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;QAChB,QAAQ;QACR,MAAO,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC,UAAU,CAAE;YAC1C,MAAM,SAAS,IAAI,CAAC,KAAK,CAAC,KAAK;YAC/B,IAAI,QAAQ,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC;QAChC;IACF;IAEA,OAAO,GAAW,EAAQ;QACxB,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC;QAClB,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAA,IAAK,MAAM;IAC5C;IAEA,eAAe,MAAc,EAAQ;QACnC,KAAK,MAAM,OAAO,MAAM,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,IAAK;YAC/C,IAAI,IAAI,UAAU,CAAC,SAAS,IAAI,CAAC,MAAM,CAAC;QAC1C;IACF;AACF;AAEO,MAAM,cAAc,IAAI,eAAe;AAEvC,SAAS,QAAQ,QAAgB,EAAE,QAA6D,EAAE;IACvG,OAAO,CAAC,MAAM,EAAE,SAAS,CAAC,EAAE,MAAM,MAAM,CAAC,CAAA,IAAK,MAAM,aAAa,MAAM,MAAM,IAAI,CAAC,MAAM;AAC1F","debugId":null}},
    {"offset": {"line": 198, "column": 0}, "map": {"version":3,"sources":["file:///D:/majalgav/hosting%20admin/apps/admin-app/src/lib/admin-auth.ts"],"sourcesContent":["import { NextRequest } from \"next/server\";\nimport { cookies } from \"next/headers\";\nimport { adminAuth, adminDb } from \"./firebase-admin\";\n\n// Admin authentication helper that verifies against admins collection\nexport async function verifyAdminAuth() {\n  try {\n    const cookieStore = await cookies();\n    const token = cookieStore.get('admin-token')?.value;\n    \n    // For development, we'll allow access with a simple token check\n    if (token === 'dev_admin_token') {\n      return { \n        adminId: \"dev_admin\", \n        name: \"Development Admin\",\n        email: \"admin@docuploaer.com\",\n        role: \"admin\"\n      };\n    }\n\n    if (!token) {\n      throw new Error('No admin authentication token found');\n    }\n\n    // Verify the token with Firebase Admin\n    const decodedToken = await adminAuth.verifyIdToken(token);\n    \n    // Check if this is a custom token with admin role\n    if (decodedToken.role === 'admin') {\n      return {\n        adminId: decodedToken.adminId || decodedToken.uid,\n        name: decodedToken.name || 'Admin',\n        email: decodedToken.email || 'admin@example.com',\n        role: \"admin\"\n      };\n    }\n    \n    // Get admin data from admins collection\n    const adminDoc = await adminDb.collection('admins').doc(decodedToken.uid).get();\n    \n    if (!adminDoc.exists) {\n      throw new Error('Admin not found in database');\n    }\n\n    const adminData = adminDoc.data();\n    \n    if (!adminData?.isActive) {\n      throw new Error('Admin account is deactivated');\n    }\n\n    return {\n      adminId: decodedToken.uid,\n      name: adminData.name,\n      email: adminData.email,\n      role: \"admin\"\n    };\n  } catch (error) {\n    // For development, return default admin even on error\n    return { \n      adminId: \"dev_admin\", \n      name: \"Development Admin\",\n      email: \"admin@docuploaer.com\",\n      role: \"admin\"\n    };\n  }\n}\n\n// Helper function to get query parameters\nexport function getQueryParams(request: NextRequest) {\n  const { searchParams } = new URL(request.url);\n  return {\n    filter: searchParams.get('filter') || 'all',\n    dateFilter: searchParams.get('dateFilter') || 'all',\n    search: searchParams.get('search') || '',\n    limit: parseInt(searchParams.get('limit') || '50'),\n    offset: parseInt(searchParams.get('offset') || '0'),\n    status: searchParams.get('status'),\n    userId: searchParams.get('userId'),\n    fileId: searchParams.get('fileId'),\n    startDate: searchParams.get('startDate'),\n    endDate: searchParams.get('endDate')\n  };\n}\n"],"names":[],"mappings":";;;;;;AACA;AACA;;;;;;;AAGO,eAAe;IACpB,IAAI;QACF,MAAM,cAAc,MAAM,IAAA,4IAAO;QACjC,MAAM,QAAQ,YAAY,GAAG,CAAC,gBAAgB;QAE9C,gEAAgE;QAChE,IAAI,UAAU,mBAAmB;YAC/B,OAAO;gBACL,SAAS;gBACT,MAAM;gBACN,OAAO;gBACP,MAAM;YACR;QACF;QAEA,IAAI,CAAC,OAAO;YACV,MAAM,IAAI,MAAM;QAClB;QAEA,uCAAuC;QACvC,MAAM,eAAe,MAAM,sKAAS,CAAC,aAAa,CAAC;QAEnD,kDAAkD;QAClD,IAAI,aAAa,IAAI,KAAK,SAAS;YACjC,OAAO;gBACL,SAAS,aAAa,OAAO,IAAI,aAAa,GAAG;gBACjD,MAAM,aAAa,IAAI,IAAI;gBAC3B,OAAO,aAAa,KAAK,IAAI;gBAC7B,MAAM;YACR;QACF;QAEA,wCAAwC;QACxC,MAAM,WAAW,MAAM,oKAAO,CAAC,UAAU,CAAC,UAAU,GAAG,CAAC,aAAa,GAAG,EAAE,GAAG;QAE7E,IAAI,CAAC,SAAS,MAAM,EAAE;YACpB,MAAM,IAAI,MAAM;QAClB;QAEA,MAAM,YAAY,SAAS,IAAI;QAE/B,IAAI,CAAC,WAAW,UAAU;YACxB,MAAM,IAAI,MAAM;QAClB;QAEA,OAAO;YACL,SAAS,aAAa,GAAG;YACzB,MAAM,UAAU,IAAI;YACpB,OAAO,UAAU,KAAK;YACtB,MAAM;QACR;IACF,EAAE,OAAO,OAAO;QACd,sDAAsD;QACtD,OAAO;YACL,SAAS;YACT,MAAM;YACN,OAAO;YACP,MAAM;QACR;IACF;AACF;AAGO,SAAS,eAAe,OAAoB;IACjD,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,QAAQ,GAAG;IAC5C,OAAO;QACL,QAAQ,aAAa,GAAG,CAAC,aAAa;QACtC,YAAY,aAAa,GAAG,CAAC,iBAAiB;QAC9C,QAAQ,aAAa,GAAG,CAAC,aAAa;QACtC,OAAO,SAAS,aAAa,GAAG,CAAC,YAAY;QAC7C,QAAQ,SAAS,aAAa,GAAG,CAAC,aAAa;QAC/C,QAAQ,aAAa,GAAG,CAAC;QACzB,QAAQ,aAAa,GAAG,CAAC;QACzB,QAAQ,aAAa,GAAG,CAAC;QACzB,WAAW,aAAa,GAAG,CAAC;QAC5B,SAAS,aAAa,GAAG,CAAC;IAC5B;AACF","debugId":null}},
    {"offset": {"line": 286, "column": 0}, "map": {"version":3,"sources":["file:///D:/majalgav/hosting%20admin/apps/admin-app/src/app/api/admin/transactions/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\nimport { adminDb } from \"@/lib/firebase-admin\";\nimport { serverCache, makeKey } from \"@/lib/server-cache\";\nimport { verifyAdminAuth } from \"@/lib/admin-auth\";\n\n// GET - Get all transactions/payments\nexport async function GET(request: NextRequest) {\n  try {\n    // Verify admin authentication\n    const admin = await verifyAdminAuth();\n    if (!admin) {\n      return NextResponse.json({ success: false, error: 'Unauthorized' }, { status: 401 });\n    }\n    \n    const { searchParams } = new URL(request.url);\n    const status = searchParams.get('status');\n    const userId = searchParams.get('userId');\n    const page = parseInt(searchParams.get('page') || '1');\n    const limit = parseInt(searchParams.get('limit') || '50');\n    const fileId = searchParams.get('fileId');\n    const startDate = searchParams.get('startDate');\n    const endDate = searchParams.get('endDate');\n    const search = searchParams.get('search') || '';\n\n    // Enhanced cache key with all parameters including search\n    const fresh = searchParams.get('fresh') === '1';\n    const cacheKey = makeKey('transactions', [\n      status || 'all', \n      userId || 'all', \n      fileId || 'all',\n      startDate || 'all',\n      endDate || 'all',\n      search || 'all',\n      page, \n      limit\n    ]);\n    const cached = fresh ? undefined : serverCache.get<any>(cacheKey);\n    if (cached) {\n      return NextResponse.json(cached);\n    }\n\n    // Build query with limits to prevent huge data fetches\n    let query = adminDb.collection('payments');\n    \n    if (status) {\n      query = query.where('status', '==', status);\n    }\n    \n    if (userId) {\n      query = query.where('userId', '==', userId);\n    }\n    \n    if (fileId) {\n      query = query.where('fileId', '==', fileId);\n    }\n\n    // Date filtering\n    if (startDate) {\n      query = query.where('createdAt', '>=', new Date(startDate));\n    }\n    \n    if (endDate) {\n      query = query.where('createdAt', '<=', new Date(endDate));\n    }\n\n    // CRITICAL: Add limit to prevent huge queries\n    query = query.orderBy('createdAt', 'desc').limit(Math.min(limit * 2, 1000)); // Allow some buffer for filtering\n\n    const snapshot = await query.get();\n    \n    // OPTIMIZED: Batch fetch users and files with limits to prevent huge queries\n    const userIds = new Set<string>();\n    const fileIds = new Set<string>();\n    \n    snapshot.docs.forEach(doc => {\n      const data = doc.data();\n      if (data.userId) userIds.add(data.userId);\n      if (data.fileId) fileIds.add(data.fileId);\n    });\n\n    // OPTIMIZED: Use 'in' queries with limits instead of individual document fetches\n    const [usersMap, filesMap] = await Promise.all([\n      // Batch fetch users with limit\n      (async () => {\n        const map = new Map<string, any>();\n        if (userIds.size === 0) return map;\n        \n        const userIdArray = Array.from(userIds);\n        const userPromises = userIdArray.map(id => \n          adminDb.collection('users').doc(id).get()\n        );\n        const userDocs = await Promise.all(userPromises);\n        \n        userDocs.forEach((doc, idx) => {\n          if (doc.exists) {\n            map.set(userIdArray[idx], doc.data());\n          }\n        });\n        return map;\n      })(),\n      \n      // Batch fetch files with limit\n      (async () => {\n        const map = new Map<string, any>();\n        if (fileIds.size === 0) return map;\n        \n        const fileIdArray = Array.from(fileIds);\n        const filePromises = fileIdArray.map(id => \n          adminDb.collection('files').doc(id).get()\n        );\n        const fileDocs = await Promise.all(filePromises);\n        \n        fileDocs.forEach((doc, idx) => {\n          if (doc.exists) {\n            map.set(fileIdArray[idx], doc.data());\n          }\n        });\n        return map;\n      })()\n    ]);\n\n    // Map transactions with batched data\n    let transactions = snapshot.docs.map(doc => {\n      const data = doc.data();\n      const userData = usersMap.get(data.userId);\n      const fileData = filesMap.get(data.fileId);\n\n      return {\n        id: doc.id,\n        userId: data.userId,\n        fileId: data.fileId,\n        amount: data.amount,\n        currency: data.currency,\n        status: data.status,\n        razorpayOrderId: data.razorpayOrderId,\n        razorpayPaymentId: data.razorpayPaymentId,\n        paymentMethod: data.paymentMethod,\n        createdAt: data.createdAt?.toDate?.() || data.createdAt,\n        updatedAt: data.updatedAt?.toDate?.() || data.updatedAt,\n        metadata: data.metadata || {},\n        // Additional data\n        user: userData ? {\n          name: userData.name,\n          email: userData.email\n        } : null,\n        file: fileData ? {\n          originalName: fileData.originalName,\n          status: fileData.status\n        } : null\n      };\n    });\n\n    // Note: keep all transactions; do not hide orphans/pending without payment id\n\n    // Apply server-side search filter if provided\n    if (search) {\n      const searchLower = search.toLowerCase();\n      transactions = transactions.filter(t => {\n        return (\n          t.user?.name?.toLowerCase().includes(searchLower) ||\n          t.user?.email?.toLowerCase().includes(searchLower) ||\n          t.file?.originalName?.toLowerCase().includes(searchLower) ||\n          t.razorpayPaymentId?.toLowerCase().includes(searchLower) ||\n          t.razorpayOrderId?.toLowerCase().includes(searchLower)\n        );\n      });\n    }\n\n    // Deduplicate transactions by fileId (primary). If missing, fallback to orderId, then doc id.\n    // Prefer rows that have linked file/user data; then prefer better status; then latest update.\n    const statusRank: Record<string, number> = { captured: 4, refunded: 3, failed: 2, pending: 1 } as any;\n    const dedupedMap = new Map<string, any>();\n    for (const t of transactions) {\n      const key = t.fileId || t.razorpayOrderId || t.id;\n      const current = dedupedMap.get(key);\n      if (!current) {\n        dedupedMap.set(key, t);\n        continue;\n      }\n      const currentRank = statusRank[(current.status || 'pending').toLowerCase()] || 0;\n      const newRank = statusRank[(t.status || 'pending').toLowerCase()] || 0;\n      const currentTime = new Date(current.updatedAt || current.createdAt || 0).getTime();\n      const newTime = new Date(t.updatedAt || t.createdAt || 0).getTime();\n      const currentHasLinks = (current.file ? 1 : 0) + (current.user ? 1 : 0);\n      const newHasLinks = (t.file ? 1 : 0) + (t.user ? 1 : 0);\n      // Prefer linked rows; then better status; then newer time\n      if (\n        newHasLinks > currentHasLinks ||\n        (newHasLinks === currentHasLinks && newRank > currentRank) ||\n        (newHasLinks === currentHasLinks && newRank === currentRank && newTime > currentTime)\n      ) {\n        dedupedMap.set(key, t);\n      }\n    }\n    const deduped = Array.from(dedupedMap.values());\n\n    // Final cleanup: hide rows without a linked file; allow missing user details\n    const cleaned = deduped.filter(t => !!t.file);\n\n    // Apply pagination after dedupe\n    const startIndex = (page - 1) * limit;\n    const endIndex = startIndex + limit;\n    const paginatedTransactions = cleaned.slice(startIndex, endIndex);\n\n    // Calculate summary statistics\n    const totalAmount = cleaned.reduce((sum, t) => sum + t.amount, 0);\n    const successfulPayments = cleaned.filter(t => t.status === 'captured').length;\n    const failedPayments = cleaned.filter(t => t.status === 'failed').length;\n    const pendingPayments = cleaned.filter(t => t.status === 'pending').length;\n\n    const payload = {\n      success: true,\n      transactions: paginatedTransactions,\n      summary: {\n        totalTransactions: cleaned.length,\n        totalAmount,\n        successfulPayments,\n        failedPayments,\n        pendingPayments,\n        successRate: deduped.length > 0 ? ((successfulPayments / deduped.length) * 100).toFixed(2) : 0\n      },\n      // Also include stats for backward compatibility with frontend\n      stats: {\n        totalTransactions: deduped.length,\n        successfulTransactions: successfulPayments,\n        failedTransactions: failedPayments,\n        totalRevenue: totalAmount,\n        averageTransactionValue: cleaned.length > 0 ? totalAmount / cleaned.length : 0,\n        successRate: cleaned.length > 0 ? (successfulPayments / cleaned.length) * 100 : 0\n      },\n      pagination: {\n        total: cleaned.length,\n        limit: limit,\n        page: page,\n        hasMore: endIndex < cleaned.length\n      }\n    };\n    \n    if (!fresh) {\n      serverCache.set(cacheKey, payload, 10_000); // 10s cache for fresher data\n    }\n    return NextResponse.json(payload);\n\n  } catch (error: any) {\n    console.error(\"Error fetching transactions:\", error);\n    \n    return NextResponse.json(\n      { success: false, message: \"Failed to fetch transactions\" },\n      { status: 500 }\n    );\n  }\n}\n\n// POST - Update transaction status (for refunds, etc.)\nexport async function POST(request: NextRequest) {\n  try {\n    // Verify admin authentication\n    const admin = await verifyAdminAuth();\n    if (!admin) {\n      return NextResponse.json({ success: false, error: 'Unauthorized' }, { status: 401 });\n    }\n\n    const { transactionId, status, reason, refundAmount } = await request.json();\n\n    if (!transactionId || !status) {\n      return NextResponse.json(\n        { success: false, message: \"Transaction ID and status are required\" },\n        { status: 400 }\n      );\n    }\n\n    // Verify transaction exists\n    const transactionDoc = await adminDb.collection('payments').doc(transactionId).get();\n    \n    if (!transactionDoc.exists) {\n      return NextResponse.json(\n        { success: false, message: \"Transaction not found\" },\n        { status: 404 }\n      );\n    }\n\n    const transactionData = transactionDoc.data()!;\n\n    // Validate status transition\n    const validTransitions: Record<string, string[]> = {\n      'captured': ['refunded'],\n      'pending': ['captured', 'failed'],\n      'failed': ['captured'] // Retry payment\n    };\n\n    if (!validTransitions[transactionData.status]?.includes(status)) {\n      return NextResponse.json(\n        { \n          success: false, \n          message: `Invalid status transition from ${transactionData.status} to ${status}` \n        },\n        { status: 400 }\n      );\n    }\n\n    const updateData: any = {\n      status,\n      updatedAt: new Date(),\n      updatedBy: admin.adminId\n    };\n\n    if (reason) {\n      updateData.reason = reason;\n    }\n\n    if (status === 'refunded' && refundAmount) {\n      updateData.refundAmount = refundAmount;\n      updateData.refundedAt = new Date();\n    }\n\n    // Use batch for multiple updates\n    const batch = adminDb.batch();\n    \n    // Update transaction\n    const transactionRef = adminDb.collection('payments').doc(transactionId);\n    batch.update(transactionRef, updateData);\n\n    // If refunding, update file status\n    if (status === 'refunded') {\n      const fileRef = adminDb.collection('files').doc(transactionData.fileId);\n      batch.update(fileRef, {\n        status: 'refunded',\n        refundedAt: new Date(),\n        updatedAt: new Date()\n      });\n    }\n\n    // Log the action\n    const logRef = adminDb.collection('logs').doc();\n    batch.set(logRef, {\n      actionType: 'transaction_update',\n      actorId: admin.adminId,\n      actorType: 'admin',\n      transactionId,\n      details: {\n        previousStatus: transactionData.status,\n        newStatus: status,\n        reason,\n        refundAmount\n      },\n      timestamp: new Date()\n    });\n\n    await batch.commit();\n\n    // If marking as captured, remove duplicate pending entries for same file/order\n    if (status === 'captured') {\n      try {\n        const sameFilePending = await adminDb.collection('payments')\n          .where('fileId', '==', transactionData.fileId)\n          .where('status', '==', 'pending')\n          .get();\n\n        const sameOrderPending = transactionData.razorpayOrderId\n          ? await adminDb.collection('payments')\n              .where('razorpayOrderId', '==', transactionData.razorpayOrderId)\n              .where('status', '==', 'pending')\n              .get()\n          : ({ empty: true, docs: [] } as any);\n\n        const toDelete = new Set<string>();\n        sameFilePending.docs.forEach(doc => { if (doc.id !== transactionId) toDelete.add(doc.id); });\n        sameOrderPending.docs.forEach((doc: any) => { if (doc.id !== transactionId) toDelete.add(doc.id); });\n\n        if (toDelete.size > 0) {\n          const ids = Array.from(toDelete);\n          for (let i = 0; i < ids.length; i += 500) {\n            const batchDel = adminDb.batch();\n            ids.slice(i, i + 500).forEach(id => batchDel.delete(adminDb.collection('payments').doc(id)));\n            await batchDel.commit();\n          }\n        }\n      } catch (cleanupErr) {\n        console.error('Duplicate pending cleanup failed:', cleanupErr);\n      }\n    }\n\n    // Invalidate server cache for all transactions list variants\n    serverCache.deleteByPrefix(makeKey('transactions'));\n\n    return NextResponse.json({\n      success: true,\n      message: \"Transaction updated successfully\"\n    });\n\n  } catch (error: any) {\n    console.error(\"Error updating transaction:\", error);\n    \n    return NextResponse.json(\n      { success: false, message: \"Failed to update transaction\" },\n      { status: 500 }\n    );\n  }\n}\n\n// DELETE - Delete one or many transactions\nexport async function DELETE(request: NextRequest) {\n  try {\n    // Verify admin authentication\n    const admin = await verifyAdminAuth();\n    if (!admin) {\n      return NextResponse.json({ success: false, error: 'Unauthorized' }, { status: 401 });\n    }\n\n    const { transactionId, transactionIds } = await request.json();\n\n    const idsToDelete: string[] = Array.isArray(transactionIds)\n      ? transactionIds.filter(Boolean)\n      : (transactionId ? [transactionId] : []);\n\n    if (!idsToDelete.length) {\n      return NextResponse.json({ success: false, error: 'Transaction ID(s) are required' }, { status: 400 });\n    }\n\n    let deletedCount = 0;\n    const chunks: string[][] = [];\n    for (let i = 0; i < idsToDelete.length; i += 500) {\n      chunks.push(idsToDelete.slice(i, i + 500));\n    }\n\n    for (const chunk of chunks) {\n      const batch = adminDb.batch();\n      const docs = await Promise.all(chunk.map(id => adminDb.collection('payments').doc(id).get()));\n      docs.forEach((doc, idx) => {\n        if (doc.exists) {\n          batch.delete(doc.ref);\n          deletedCount += 1;\n        }\n      });\n      await batch.commit();\n    }\n\n    serverCache.deleteByPrefix('admin:transactions');\n\n    return NextResponse.json({\n      success: true,\n      message: deletedCount === 1 ? 'Transaction deleted successfully' : `Deleted ${deletedCount} transactions`,\n      deletedCount\n    });\n  } catch (error: any) {\n    console.error('Error deleting transactions:', error);\n    return NextResponse.json(\n      { success: false, message: 'Failed to delete transactions' },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}}]
}