{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 91, "column": 0}, "map": {"version":3,"sources":["file:///D:/majalgav/hosting%20admin/apps/admin-app/src/lib/firebase-admin.ts"],"sourcesContent":["import { initializeApp, getApps, cert } from 'firebase-admin/app';\nimport { getAuth } from 'firebase-admin/auth';\nimport { getFirestore } from 'firebase-admin/firestore';\nimport { getStorage } from 'firebase-admin/storage';\n\n// Initialize Firebase Admin\nconst privateKey = process.env.FIREBASE_PRIVATE_KEY?.replace(/^\"|\"$/g, '') || '';\n\nconst firebaseAdminConfig = {\n  credential: cert({\n    projectId: process.env.FIREBASE_PROJECT_ID,\n    clientEmail: process.env.FIREBASE_CLIENT_EMAIL,\n    privateKey: privateKey,\n  }),\n};\n\n// Initialize Firebase Admin\nconst adminApp = getApps().length === 0 ? initializeApp(firebaseAdminConfig) : getApps()[0];\n\n// Initialize Firebase Admin services\nexport const adminAuth = getAuth(adminApp);\nexport const adminDb = getFirestore(adminApp);\nexport const adminStorage = getStorage(adminApp);\n\nexport default adminApp;\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;;;;;;;;;;;;AAEA,4BAA4B;AAC5B,MAAM,aAAa,QAAQ,GAAG,CAAC,oBAAoB,EAAE,QAAQ,UAAU,OAAO;AAE9E,MAAM,sBAAsB;IAC1B,YAAY,IAAA,wJAAI,EAAC;QACf,WAAW,QAAQ,GAAG,CAAC,mBAAmB;QAC1C,aAAa,QAAQ,GAAG,CAAC,qBAAqB;QAC9C,YAAY;IACd;AACF;AAEA,4BAA4B;AAC5B,MAAM,WAAW,IAAA,2JAAO,IAAG,MAAM,KAAK,IAAI,IAAA,iKAAa,EAAC,uBAAuB,IAAA,2JAAO,GAAE,CAAC,EAAE;AAGpF,MAAM,YAAY,IAAA,6JAAO,EAAC;AAC1B,MAAM,UAAU,IAAA,4KAAY,EAAC;AAC7B,MAAM,eAAe,IAAA,sKAAU,EAAC;uCAExB","debugId":null}},
    {"offset": {"line": 136, "column": 0}, "map": {"version":3,"sources":["file:///D:/majalgav/hosting%20admin/apps/admin-app/src/lib/server-cache.ts"],"sourcesContent":["type CacheEntry<T> = { data: T; expiresAt: number };\r\n\r\nclass SimpleLRUCache {\r\n  private store = new Map<string, CacheEntry<any>>();\r\n  private order: string[] = [];\r\n  constructor(private maxEntries: number = 200) {}\r\n\r\n  get<T>(key: string): T | undefined {\r\n    const entry = this.store.get(key);\r\n    if (!entry) return undefined;\r\n    if (Date.now() > entry.expiresAt) {\r\n      this.delete(key);\r\n      return undefined;\r\n    }\r\n    // touch\r\n    this.order = this.order.filter(k => k !== key);\r\n    this.order.push(key);\r\n    return entry.data as T;\r\n    }\r\n\r\n  set<T>(key: string, value: T, ttlMs: number): void {\r\n    const expiresAt = Date.now() + ttlMs;\r\n    this.store.set(key, { data: value, expiresAt });\r\n    this.order = this.order.filter(k => k !== key);\r\n    this.order.push(key);\r\n    // evict\r\n    while (this.order.length > this.maxEntries) {\r\n      const oldest = this.order.shift();\r\n      if (oldest) this.store.delete(oldest);\r\n    }\r\n  }\r\n\r\n  delete(key: string): void {\r\n    this.store.delete(key);\r\n    this.order = this.order.filter(k => k !== key);\r\n  }\r\n\r\n  deleteByPrefix(prefix: string): void {\r\n    for (const key of Array.from(this.store.keys())) {\r\n      if (key.startsWith(prefix)) this.delete(key);\r\n    }\r\n  }\r\n}\r\n\r\nexport const serverCache = new SimpleLRUCache(300);\r\n\r\nexport function makeKey(resource: string, parts: Array<string | number | boolean | null | undefined> = []) {\r\n  return `admin:${resource}:${parts.filter(v => v !== undefined && v !== null).join(':')}`;\r\n}\r\n\r\n\r\n\r\n\r\n"],"names":[],"mappings":";;;;;;AAEA,MAAM;;IACI,MAA2C;IAC3C,MAAqB;IAC7B,YAAY,AAAQ,aAAqB,GAAG,CAAE;aAA1B,aAAA;aAFZ,QAAQ,IAAI;aACZ,QAAkB,EAAE;IACmB;IAE/C,IAAO,GAAW,EAAiB;QACjC,MAAM,QAAQ,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;QAC7B,IAAI,CAAC,OAAO,OAAO;QACnB,IAAI,KAAK,GAAG,KAAK,MAAM,SAAS,EAAE;YAChC,IAAI,CAAC,MAAM,CAAC;YACZ,OAAO;QACT;QACA,QAAQ;QACR,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAA,IAAK,MAAM;QAC1C,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;QAChB,OAAO,MAAM,IAAI;IACjB;IAEF,IAAO,GAAW,EAAE,KAAQ,EAAE,KAAa,EAAQ;QACjD,MAAM,YAAY,KAAK,GAAG,KAAK;QAC/B,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,KAAK;YAAE,MAAM;YAAO;QAAU;QAC7C,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAA,IAAK,MAAM;QAC1C,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;QAChB,QAAQ;QACR,MAAO,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC,UAAU,CAAE;YAC1C,MAAM,SAAS,IAAI,CAAC,KAAK,CAAC,KAAK;YAC/B,IAAI,QAAQ,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC;QAChC;IACF;IAEA,OAAO,GAAW,EAAQ;QACxB,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC;QAClB,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAA,IAAK,MAAM;IAC5C;IAEA,eAAe,MAAc,EAAQ;QACnC,KAAK,MAAM,OAAO,MAAM,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,IAAK;YAC/C,IAAI,IAAI,UAAU,CAAC,SAAS,IAAI,CAAC,MAAM,CAAC;QAC1C;IACF;AACF;AAEO,MAAM,cAAc,IAAI,eAAe;AAEvC,SAAS,QAAQ,QAAgB,EAAE,QAA6D,EAAE;IACvG,OAAO,CAAC,MAAM,EAAE,SAAS,CAAC,EAAE,MAAM,MAAM,CAAC,CAAA,IAAK,MAAM,aAAa,MAAM,MAAM,IAAI,CAAC,MAAM;AAC1F","debugId":null}},
    {"offset": {"line": 197, "column": 0}, "map": {"version":3,"sources":["file:///D:/majalgav/hosting%20admin/apps/admin-app/src/lib/admin-auth.ts"],"sourcesContent":["import { NextRequest } from \"next/server\";\nimport { cookies } from \"next/headers\";\nimport { adminAuth, adminDb } from \"./firebase-admin\";\n\n// Admin authentication helper that verifies against admins collection\nexport async function verifyAdminAuth() {\n  try {\n    const cookieStore = await cookies();\n    const token = cookieStore.get('admin-token')?.value;\n    \n    // For development, we'll allow access with a simple token check\n    if (token === 'dev_admin_token') {\n      return { \n        adminId: \"dev_admin\", \n        name: \"Development Admin\",\n        email: \"admin@docuploaer.com\",\n        role: \"admin\"\n      };\n    }\n\n    if (!token) {\n      throw new Error('No admin authentication token found');\n    }\n\n    // Verify the token with Firebase Admin\n    const decodedToken = await adminAuth.verifyIdToken(token);\n    \n    // Check if this is a custom token with admin role\n    if (decodedToken.role === 'admin') {\n      return {\n        adminId: decodedToken.adminId || decodedToken.uid,\n        name: decodedToken.name || 'Admin',\n        email: decodedToken.email || 'admin@example.com',\n        role: \"admin\"\n      };\n    }\n    \n    // Get admin data from admins collection\n    const adminDoc = await adminDb.collection('admins').doc(decodedToken.uid).get();\n    \n    if (!adminDoc.exists) {\n      throw new Error('Admin not found in database');\n    }\n\n    const adminData = adminDoc.data();\n    \n    if (!adminData?.isActive) {\n      throw new Error('Admin account is deactivated');\n    }\n\n    return {\n      adminId: decodedToken.uid,\n      name: adminData.name,\n      email: adminData.email,\n      role: \"admin\"\n    };\n  } catch (error) {\n    // For development, return default admin even on error\n    return { \n      adminId: \"dev_admin\", \n      name: \"Development Admin\",\n      email: \"admin@docuploaer.com\",\n      role: \"admin\"\n    };\n  }\n}\n\n// Helper function to get query parameters\nexport function getQueryParams(request: NextRequest) {\n  const { searchParams } = new URL(request.url);\n  return {\n    filter: searchParams.get('filter') || 'all',\n    dateFilter: searchParams.get('dateFilter') || 'all',\n    search: searchParams.get('search') || '',\n    limit: parseInt(searchParams.get('limit') || '50'),\n    offset: parseInt(searchParams.get('offset') || '0'),\n    status: searchParams.get('status'),\n    userId: searchParams.get('userId'),\n    fileId: searchParams.get('fileId'),\n    startDate: searchParams.get('startDate'),\n    endDate: searchParams.get('endDate')\n  };\n}\n"],"names":[],"mappings":";;;;;;AACA;AACA;;;;;;;AAGO,eAAe;IACpB,IAAI;QACF,MAAM,cAAc,MAAM,IAAA,4IAAO;QACjC,MAAM,QAAQ,YAAY,GAAG,CAAC,gBAAgB;QAE9C,gEAAgE;QAChE,IAAI,UAAU,mBAAmB;YAC/B,OAAO;gBACL,SAAS;gBACT,MAAM;gBACN,OAAO;gBACP,MAAM;YACR;QACF;QAEA,IAAI,CAAC,OAAO;YACV,MAAM,IAAI,MAAM;QAClB;QAEA,uCAAuC;QACvC,MAAM,eAAe,MAAM,sKAAS,CAAC,aAAa,CAAC;QAEnD,kDAAkD;QAClD,IAAI,aAAa,IAAI,KAAK,SAAS;YACjC,OAAO;gBACL,SAAS,aAAa,OAAO,IAAI,aAAa,GAAG;gBACjD,MAAM,aAAa,IAAI,IAAI;gBAC3B,OAAO,aAAa,KAAK,IAAI;gBAC7B,MAAM;YACR;QACF;QAEA,wCAAwC;QACxC,MAAM,WAAW,MAAM,oKAAO,CAAC,UAAU,CAAC,UAAU,GAAG,CAAC,aAAa,GAAG,EAAE,GAAG;QAE7E,IAAI,CAAC,SAAS,MAAM,EAAE;YACpB,MAAM,IAAI,MAAM;QAClB;QAEA,MAAM,YAAY,SAAS,IAAI;QAE/B,IAAI,CAAC,WAAW,UAAU;YACxB,MAAM,IAAI,MAAM;QAClB;QAEA,OAAO;YACL,SAAS,aAAa,GAAG;YACzB,MAAM,UAAU,IAAI;YACpB,OAAO,UAAU,KAAK;YACtB,MAAM;QACR;IACF,EAAE,OAAO,OAAO;QACd,sDAAsD;QACtD,OAAO;YACL,SAAS;YACT,MAAM;YACN,OAAO;YACP,MAAM;QACR;IACF;AACF;AAGO,SAAS,eAAe,OAAoB;IACjD,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,QAAQ,GAAG;IAC5C,OAAO;QACL,QAAQ,aAAa,GAAG,CAAC,aAAa;QACtC,YAAY,aAAa,GAAG,CAAC,iBAAiB;QAC9C,QAAQ,aAAa,GAAG,CAAC,aAAa;QACtC,OAAO,SAAS,aAAa,GAAG,CAAC,YAAY;QAC7C,QAAQ,SAAS,aAAa,GAAG,CAAC,aAAa;QAC/C,QAAQ,aAAa,GAAG,CAAC;QACzB,QAAQ,aAAa,GAAG,CAAC;QACzB,QAAQ,aAAa,GAAG,CAAC;QACzB,WAAW,aAAa,GAAG,CAAC;QAC5B,SAAS,aAAa,GAAG,CAAC;IAC5B;AACF","debugId":null}},
    {"offset": {"line": 285, "column": 0}, "map": {"version":3,"sources":["file:///D:/majalgav/hosting%20admin/apps/admin-app/src/app/api/admin/agents/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\nimport { adminDb, adminAuth } from \"@/lib/firebase-admin\";\nimport { serverCache, makeKey } from \"@/lib/server-cache\";\nimport { verifyAdminAuth } from \"@/lib/admin-auth\";\n\n// Helper function to handle Firestore connection issues with retry logic\nasync function withRetry<T>(\n  operation: () => Promise<T>,\n  maxRetries: number = 3,\n  delay: number = 1000\n): Promise<T> {\n  let lastError: any;\n  \n  for (let attempt = 1; attempt <= maxRetries; attempt++) {\n    try {\n      return await operation();\n    } catch (error: any) {\n      lastError = error;\n      \n      // Check if it's a connection error that we should retry\n      if (error.code === 14 || // UNAVAILABLE\n          error.message?.includes('No connection established') ||\n          error.message?.includes('network socket disconnected') ||\n          error.message?.includes('TLS connection') ||\n          error.code === 'ECONNRESET' ||\n          error.code === 'ENOTFOUND') {\n        \n        // Retrying...\n        \n        if (attempt < maxRetries) {\n          await new Promise(resolve => setTimeout(resolve, delay));\n          delay *= 2; // Exponential backoff\n          continue;\n        }\n      }\n      \n      // If it's not a retryable error or we've exhausted retries, throw\n      throw error;\n    }\n  }\n  \n  throw lastError;\n}\n\n// GET - List all agents\nexport async function GET(request: NextRequest) {\n  try {\n    // Verify admin authentication\n    const admin = await verifyAdminAuth();\n    if (!admin) {\n      return NextResponse.json({ success: false, error: 'Unauthorized' }, { status: 401 });\n    }\n\n    const { searchParams } = new URL(request.url);\n    const page = parseInt(searchParams.get('page') || '1');\n    const limit = Math.min(parseInt(searchParams.get('limit') || '100'), 100); // Cap at 100\n    const search = (searchParams.get('search') || '').toLowerCase();\n    const status = searchParams.get('status') || 'all';\n    const includeStats = searchParams.get('includeStats') === 'true';\n\n    // More aggressive caching - agent data changes infrequently\n    const cacheKey = makeKey('agents', ['list', page, limit, status || 'all', search || '', includeStats]);\n    const cached = serverCache.get<any>(cacheKey);\n    if (cached) {\n      return NextResponse.json(cached);\n    }\n\n    // Build optimized Firestore query with database-level limits\n    let baseQuery: FirebaseFirestore.Query = adminDb.collection('agents');\n    \n    // Apply status filter at database level\n    if (status !== 'all') {\n      const isActive = status === 'active';\n      baseQuery = baseQuery.where('isActive', '==', isActive);\n    }\n    \n    // Sort by createdAt desc\n    baseQuery = baseQuery.orderBy('createdAt', 'desc');\n    \n    // Apply reasonable limit to prevent fetching thousands of agents\n    // For search, we need more records; otherwise use strict limit\n    const queryLimit = search ? 1000 : limit * 2; // Allow some buffer for pagination\n    baseQuery = baseQuery.limit(queryLimit);\n    \n    // Use retry logic for the main query\n    const snapshot = await withRetry(() => baseQuery.get());\n\n    // Map agents data (minimal transformation)\n    let agents = snapshot.docs.map(doc => {\n      const data = doc.data();\n      return { \n        id: doc.id, \n        email: data.email,\n        name: data.name,\n        isActive: data.isActive,\n        createdAt: data.createdAt,\n        lastLoginAt: data.lastLoginAt,\n        phone: data.phone,\n        role: 'agent' \n      };\n    });\n    \n    // Apply search filter in memory (Firestore doesn't support LIKE queries)\n    if (search) {\n      agents = agents.filter(agent =>\n        agent.name?.toLowerCase().includes(search) ||\n        agent.email?.toLowerCase().includes(search) ||\n        agent.phone?.toLowerCase().includes(search)\n      );\n    }\n\n    const totalAgents = agents.length;\n\n    // Apply pagination in memory\n    const startIndex = (Number(page) - 1) * Number(limit);\n    const endIndex = startIndex + Number(limit);\n    const paginatedAgents = agents.slice(startIndex, endIndex);\n\n    // OPTIMIZED: Get stats for ALL agents in ONE BATCH QUERY instead of N queries\n    let agentsWithStats = paginatedAgents;\n    \n    if (includeStats) {\n      const agentIds = paginatedAgents.map(a => a.id);\n      \n      if (agentIds.length > 0) {\n        // OPTIMIZED: Use aggregation queries with limits for better performance\n        const statsMap = new Map<string, { totalFiles: number, completedFiles: number, pendingFiles: number }>();\n        \n        // Initialize all agents with zero stats\n        agentIds.forEach(id => {\n          statsMap.set(id, { totalFiles: 0, completedFiles: 0, pendingFiles: 0 });\n        });\n        \n        // Process agents in batches of 10 (Firestore 'in' query limit)\n        for (let i = 0; i < agentIds.length; i += 10) {\n          const batchIds = agentIds.slice(i, Math.min(i + 10, agentIds.length));\n          \n          // Get files for this batch with limit to prevent huge queries\n          const batchSnapshot = await withRetry(() => \n            adminDb.collection('files')\n              .where('assignedAgentId', 'in', batchIds)\n              .limit(1000) // Limit to prevent huge queries\n              .get()\n          );\n          \n          batchSnapshot.forEach(doc => {\n            const data = doc.data();\n            const agentId = data.assignedAgentId;\n            if (agentId && statsMap.has(agentId)) {\n              const stats = statsMap.get(agentId)!;\n              stats.totalFiles += 1;\n              if (data.status === 'completed') stats.completedFiles += 1;\n              if (data.status === 'paid' || data.status === 'processing') stats.pendingFiles += 1;\n            }\n          });\n        }\n\n        agentsWithStats = paginatedAgents.map(agent => ({\n          id: agent.id,\n          email: agent.email,\n          name: agent.name,\n          role: 'agent',\n          isActive: agent.isActive,\n          createdAt: agent.createdAt?.toDate?.() || agent.createdAt,\n          lastLoginAt: agent.lastLoginAt?.toDate?.() || agent.lastLoginAt,\n          phone: agent.phone || null,\n          stats: statsMap.get(agent.id) || { totalFiles: 0, completedFiles: 0, pendingFiles: 0 }\n        }));\n      }\n    } else {\n      // ALWAYS return stats with default values to prevent undefined errors\n      agentsWithStats = paginatedAgents.map(agent => ({\n        id: agent.id,\n        email: agent.email,\n        name: agent.name,\n        role: 'agent',\n        isActive: agent.isActive,\n        createdAt: agent.createdAt?.toDate?.() || agent.createdAt,\n        lastLoginAt: agent.lastLoginAt?.toDate?.() || agent.lastLoginAt,\n        phone: agent.phone || null,\n        stats: { totalFiles: 0, completedFiles: 0, pendingFiles: 0 }\n      }));\n    }\n\n    const payload = {\n      success: true,\n      agents: agentsWithStats,\n      pagination: {\n        page: Number(page),\n        limit: Number(limit),\n        total: totalAgents,\n        pages: Math.ceil(totalAgents / Number(limit)),\n        hasMore: endIndex < totalAgents\n      }\n    };\n    \n    // Longer cache for agent data (5 minutes) since it changes infrequently\n    serverCache.set(cacheKey, payload, 300_000); // 5 min cache\n    return NextResponse.json(payload);\n\n  } catch (error: any) {\n    console.error(\"Error fetching agents:\", error);\n    \n    // Handle specific error types\n    if (error.code === 14 || error.message?.includes('No connection established')) {\n      return NextResponse.json(\n        { success: false, error: \"Database connection failed. Please try again.\" },\n        { status: 503 }\n      );\n    }\n    \n    if (error.name === 'AbortError' || error.message?.includes('timeout')) {\n      return NextResponse.json(\n        { success: false, error: \"Request timed out. Please try again.\" },\n        { status: 408 }\n      );\n    }\n    \n    return NextResponse.json(\n      { success: false, error: \"Failed to fetch agents\" },\n      { status: 500 }\n    );\n  }\n}\n\n// POST - Create new agent\nexport async function POST(request: NextRequest) {\n  try {\n    // Verify admin authentication\n    const admin = await verifyAdminAuth();\n    if (!admin) {\n      return NextResponse.json({ success: false, error: 'Unauthorized' }, { status: 401 });\n    }\n\n    const { email, name, password, phone } = await request.json();\n\n    // Trim and validate inputs\n    const trimmedEmail = email?.trim();\n    const trimmedName = name?.trim();\n    \n    if (!trimmedEmail || !trimmedName || !password) {\n      return NextResponse.json(\n        { success: false, error: \"Email, name, and password are required\" },\n        { status: 400 }\n      );\n    }\n\n    // Validate email format\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    if (!emailRegex.test(trimmedEmail)) {\n      return NextResponse.json(\n        { success: false, error: \"Please enter a valid email address\" },\n        { status: 400 }\n      );\n    }\n\n    // Validate password length\n    if (password.length < 6) {\n      return NextResponse.json(\n        { success: false, error: \"Password must be at least 6 characters long\" },\n        { status: 400 }\n      );\n    }\n\n    // Check if user already exists\n    const existingUser = await adminAuth.getUserByEmail(trimmedEmail).catch(() => null);\n    if (existingUser) {\n      return NextResponse.json(\n        { success: false, error: \"User with this email already exists\" },\n        { status: 409 }\n      );\n    }\n\n    // Create user in Firebase Auth\n    const userRecord = await adminAuth.createUser({\n      email: trimmedEmail,\n      password,\n      displayName: trimmedName\n    });\n\n    // Create agent document in agents collection\n    const agentData = {\n      email: trimmedEmail,\n      name: trimmedName,\n      phone: phone?.trim() || null,\n      isActive: true,\n      createdAt: new Date(),\n      createdBy: admin.adminId,\n      // Agent-specific fields\n      maxConcurrentFiles: 10, // Default limit\n      specializations: [], // Can be added later\n      performance: {\n        totalFilesProcessed: 0,\n        averageResponseTime: 0,\n        rating: 0\n      }\n    };\n\n    // OPTIMIZED: Run Firestore writes in parallel\n    await Promise.all([\n      adminDb.collection('agents').doc(userRecord.uid).set(agentData),\n      // Log the action\n      adminDb.collection('logs').add({\n        action: 'agent_created',\n        adminId: admin.adminId,\n        adminName: admin.name,\n        targetUserId: userRecord.uid,\n        details: {\n          email: trimmedEmail,\n          name: trimmedName,\n          phone: phone?.trim() || null\n        },\n        timestamp: new Date()\n      })\n    ]);\n    \n    // Invalidate cache after successful creation\n    serverCache.deleteByPrefix(makeKey('agents', ['list']));\n\n    return NextResponse.json({\n      success: true,\n      message: \"Agent created successfully\",\n      data: {\n        agent: {\n          id: userRecord.uid,\n          email: trimmedEmail,\n          name: trimmedName,\n          isActive: true,\n          createdAt: agentData.createdAt,\n          phone: phone?.trim() || null\n        }\n      }\n    });\n\n  } catch (error: any) {\n    console.error(\"Error creating agent:\", error);\n    \n    if (error.code === 'adminAuth/email-already-exists') {\n      return NextResponse.json(\n        { success: false, error: \"Agent with this email already exists\" },\n        { status: 409 }\n      );\n    }\n\n    return NextResponse.json(\n      { success: false, error: \"Failed to create agent\" },\n      { status: 500 }\n    );\n  }\n}\n\n// PUT - Update agent\nexport async function PUT(request: NextRequest) {\n  try {\n    // Verify admin authentication\n    const admin = await verifyAdminAuth();\n    if (!admin) {\n      return NextResponse.json({ success: false, error: 'Unauthorized' }, { status: 401 });\n    }\n\n    const { agentId, name, email, isActive, phone, maxConcurrentFiles, specializations } = await request.json();\n\n    if (!agentId) {\n      return NextResponse.json(\n        { success: false, error: \"Agent ID is required\" },\n        { status: 400 }\n      );\n    }\n\n    // Check if agent exists\n    const agentDoc = await adminDb.collection('agents').doc(agentId).get();\n    if (!agentDoc.exists) {\n      return NextResponse.json(\n        { success: false, error: \"Agent not found\" },\n        { status: 404 }\n      );\n    }\n\n    const updateData: any = {\n      updatedAt: new Date(),\n      updatedBy: admin.adminId\n    };\n\n    if (name !== undefined) updateData.name = name;\n    if (email !== undefined) updateData.email = email;\n    if (isActive !== undefined) updateData.isActive = isActive;\n    if (phone !== undefined) updateData.phone = phone;\n    if (maxConcurrentFiles !== undefined) updateData.maxConcurrentFiles = maxConcurrentFiles;\n    if (specializations !== undefined) updateData.specializations = specializations;\n\n    // OPTIMIZED: Run Firestore updates and Auth updates in parallel\n    const updatePromises: Promise<any>[] = [\n      adminDb.collection('agents').doc(agentId).update(updateData)\n    ];\n\n    // Build Auth update object\n    const authUpdates: any = {};\n    if (email !== undefined) authUpdates.email = email;\n    if (isActive !== undefined) authUpdates.disabled = !isActive;\n    \n    // If there are auth updates, add to parallel execution\n    if (Object.keys(authUpdates).length > 0) {\n      updatePromises.push(adminAuth.updateUser(agentId, authUpdates));\n    }\n\n    // Add logging to parallel execution\n    updatePromises.push(\n      adminDb.collection('logs').add({\n        action: 'agent_updated',\n        adminId: admin.adminId,\n        adminName: admin.name,\n        targetUserId: agentId,\n        details: updateData,\n        timestamp: new Date()\n      })\n    );\n\n    // Execute all updates in parallel\n    await Promise.all(updatePromises);\n    \n    // Invalidate cache after successful update\n    serverCache.deleteByPrefix(makeKey('agents', ['list']));\n\n    return NextResponse.json({\n      success: true,\n      message: \"Agent updated successfully\"\n    });\n\n  } catch (error: any) {\n    console.error(\"Error updating agent:\", error);\n    return NextResponse.json(\n      { success: false, error: \"Failed to update agent\" },\n      { status: 500 }\n    );\n  }\n}\n\n// DELETE - Deactivate agent (soft delete)\nexport async function DELETE(request: NextRequest) {\n  try {\n    // Verify admin authentication\n    const admin = await verifyAdminAuth();\n    if (!admin) {\n      return NextResponse.json({ success: false, error: 'Unauthorized' }, { status: 401 });\n    }\n\n    const { searchParams } = new URL(request.url);\n    const agentId = searchParams.get('agentId');\n\n    if (!agentId) {\n      return NextResponse.json(\n        { success: false, error: \"Agent ID is required\" },\n        { status: 400 }\n      );\n    }\n\n    // Check if agent exists\n    const agentDoc = await adminDb.collection('agents').doc(agentId).get();\n    if (!agentDoc.exists) {\n      return NextResponse.json(\n        { success: false, error: \"Agent not found\" },\n        { status: 404 }\n      );\n    }\n\n    // Check if agent has pending files\n    const pendingFilesSnapshot = await adminDb.collection('files')\n      .where('assignedAgentId', '==', agentId)\n      .where('status', 'in', ['paid', 'processing'])\n      .get();\n\n    if (pendingFilesSnapshot.size > 0) {\n      return NextResponse.json(\n        { \n          success: false, \n          error: `Cannot deactivate agent. ${pendingFilesSnapshot.size} files are still pending. Please reassign them first.` \n        },\n        { status: 400 }\n      );\n    }\n\n    // OPTIMIZED: Run deactivation operations in parallel\n    await Promise.all([\n      // Soft delete - deactivate agent in Firestore\n      adminDb.collection('agents').doc(agentId).update({\n        isActive: false,\n        deactivatedAt: new Date(),\n        deactivatedBy: admin.adminId,\n        updatedAt: new Date()\n      }),\n      // Disable agent in Firebase Auth\n      adminAuth.updateUser(agentId, { disabled: true }),\n      // Log the action\n      adminDb.collection('logs').add({\n        action: 'agent_deactivated',\n        adminId: admin.adminId,\n        adminName: admin.name,\n        targetUserId: agentId,\n        details: {\n          reason: 'Admin deactivation'\n        },\n        timestamp: new Date()\n      })\n    ]);\n    \n    // Invalidate cache after successful deactivation\n    serverCache.deleteByPrefix(makeKey('agents', ['list']));\n\n    return NextResponse.json({\n      success: true,\n      message: \"Agent deactivated successfully\"\n    });\n\n  } catch (error: any) {\n    console.error(\"Error deactivating agent:\", error);\n    return NextResponse.json(\n      { success: false, error: \"Failed to deactivate agent\" },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}}]
}