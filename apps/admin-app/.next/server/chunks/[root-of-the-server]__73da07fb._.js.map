{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 91, "column": 0}, "map": {"version":3,"sources":["file:///D:/majalgav/hosting%20admin/apps/admin-app/src/lib/firebase-admin.ts"],"sourcesContent":["import { initializeApp, getApps, cert } from 'firebase-admin/app';\nimport { getAuth } from 'firebase-admin/auth';\nimport { getFirestore } from 'firebase-admin/firestore';\nimport { getStorage } from 'firebase-admin/storage';\n\n// Initialize Firebase Admin\n// Handle both true multiline and \"\\n\"-escaped private keys\nconst privateKey = (process.env.FIREBASE_PRIVATE_KEY || '')\n  .replace(/^\"|\"$/g, '')\n  .replace(/\\\\n/g, '\\n');\n\nconst firebaseAdminConfig = {\n  credential: cert({\n    projectId: process.env.FIREBASE_PROJECT_ID,\n    clientEmail: process.env.FIREBASE_CLIENT_EMAIL,\n    privateKey: privateKey,\n  }),\n};\n\n// Initialize Firebase Admin\nconst adminApp = getApps().length === 0 ? initializeApp(firebaseAdminConfig) : getApps()[0];\n\n// Initialize Firebase Admin services\nexport const adminAuth = getAuth(adminApp);\nexport const adminDb = getFirestore(adminApp);\nexport const adminStorage = getStorage(adminApp);\n\nexport default adminApp;\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;;;;;;;;;;;;AAEA,4BAA4B;AAC5B,2DAA2D;AAC3D,MAAM,aAAa,CAAC,QAAQ,GAAG,CAAC,oBAAoB,IAAI,EAAE,EACvD,OAAO,CAAC,UAAU,IAClB,OAAO,CAAC,QAAQ;AAEnB,MAAM,sBAAsB;IAC1B,YAAY,IAAA,wJAAI,EAAC;QACf,WAAW,QAAQ,GAAG,CAAC,mBAAmB;QAC1C,aAAa,QAAQ,GAAG,CAAC,qBAAqB;QAC9C,YAAY;IACd;AACF;AAEA,4BAA4B;AAC5B,MAAM,WAAW,IAAA,2JAAO,IAAG,MAAM,KAAK,IAAI,IAAA,iKAAa,EAAC,uBAAuB,IAAA,2JAAO,GAAE,CAAC,EAAE;AAGpF,MAAM,YAAY,IAAA,6JAAO,EAAC;AAC1B,MAAM,UAAU,IAAA,4KAAY,EAAC;AAC7B,MAAM,eAAe,IAAA,sKAAU,EAAC;uCAExB","debugId":null}},
    {"offset": {"line": 137, "column": 0}, "map": {"version":3,"sources":["file:///D:/majalgav/hosting%20admin/apps/admin-app/src/lib/server-cache.ts"],"sourcesContent":["type CacheEntry<T> = { data: T; expiresAt: number };\r\n\r\nclass SimpleLRUCache {\r\n  private store = new Map<string, CacheEntry<any>>();\r\n  private order: string[] = [];\r\n  constructor(private maxEntries: number = 200) {}\r\n\r\n  get<T>(key: string): T | undefined {\r\n    const entry = this.store.get(key);\r\n    if (!entry) return undefined;\r\n    if (Date.now() > entry.expiresAt) {\r\n      this.delete(key);\r\n      return undefined;\r\n    }\r\n    // touch\r\n    this.order = this.order.filter(k => k !== key);\r\n    this.order.push(key);\r\n    return entry.data as T;\r\n    }\r\n\r\n  set<T>(key: string, value: T, ttlMs: number): void {\r\n    const expiresAt = Date.now() + ttlMs;\r\n    this.store.set(key, { data: value, expiresAt });\r\n    this.order = this.order.filter(k => k !== key);\r\n    this.order.push(key);\r\n    // evict\r\n    while (this.order.length > this.maxEntries) {\r\n      const oldest = this.order.shift();\r\n      if (oldest) this.store.delete(oldest);\r\n    }\r\n  }\r\n\r\n  delete(key: string): void {\r\n    this.store.delete(key);\r\n    this.order = this.order.filter(k => k !== key);\r\n  }\r\n\r\n  deleteByPrefix(prefix: string): void {\r\n    for (const key of Array.from(this.store.keys())) {\r\n      if (key.startsWith(prefix)) this.delete(key);\r\n    }\r\n  }\r\n}\r\n\r\nexport const serverCache = new SimpleLRUCache(300);\r\n\r\nexport function makeKey(resource: string, parts: Array<string | number | boolean | null | undefined> = []) {\r\n  return `admin:${resource}:${parts.filter(v => v !== undefined && v !== null).join(':')}`;\r\n}\r\n\r\n\r\n\r\n\r\n"],"names":[],"mappings":";;;;;;AAEA,MAAM;;IACI,MAA2C;IAC3C,MAAqB;IAC7B,YAAY,AAAQ,aAAqB,GAAG,CAAE;aAA1B,aAAA;aAFZ,QAAQ,IAAI;aACZ,QAAkB,EAAE;IACmB;IAE/C,IAAO,GAAW,EAAiB;QACjC,MAAM,QAAQ,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;QAC7B,IAAI,CAAC,OAAO,OAAO;QACnB,IAAI,KAAK,GAAG,KAAK,MAAM,SAAS,EAAE;YAChC,IAAI,CAAC,MAAM,CAAC;YACZ,OAAO;QACT;QACA,QAAQ;QACR,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAA,IAAK,MAAM;QAC1C,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;QAChB,OAAO,MAAM,IAAI;IACjB;IAEF,IAAO,GAAW,EAAE,KAAQ,EAAE,KAAa,EAAQ;QACjD,MAAM,YAAY,KAAK,GAAG,KAAK;QAC/B,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,KAAK;YAAE,MAAM;YAAO;QAAU;QAC7C,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAA,IAAK,MAAM;QAC1C,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;QAChB,QAAQ;QACR,MAAO,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC,UAAU,CAAE;YAC1C,MAAM,SAAS,IAAI,CAAC,KAAK,CAAC,KAAK;YAC/B,IAAI,QAAQ,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC;QAChC;IACF;IAEA,OAAO,GAAW,EAAQ;QACxB,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC;QAClB,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAA,IAAK,MAAM;IAC5C;IAEA,eAAe,MAAc,EAAQ;QACnC,KAAK,MAAM,OAAO,MAAM,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,IAAK;YAC/C,IAAI,IAAI,UAAU,CAAC,SAAS,IAAI,CAAC,MAAM,CAAC;QAC1C;IACF;AACF;AAEO,MAAM,cAAc,IAAI,eAAe;AAEvC,SAAS,QAAQ,QAAgB,EAAE,QAA6D,EAAE;IACvG,OAAO,CAAC,MAAM,EAAE,SAAS,CAAC,EAAE,MAAM,MAAM,CAAC,CAAA,IAAK,MAAM,aAAa,MAAM,MAAM,IAAI,CAAC,MAAM;AAC1F","debugId":null}},
    {"offset": {"line": 198, "column": 0}, "map": {"version":3,"sources":["file:///D:/majalgav/hosting%20admin/apps/admin-app/src/lib/admin-auth.ts"],"sourcesContent":["import { NextRequest } from \"next/server\";\nimport { cookies } from \"next/headers\";\nimport { adminAuth, adminDb } from \"./firebase-admin\";\n\n// Admin authentication helper that verifies against admins collection\nexport async function verifyAdminAuth() {\n  try {\n    const cookieStore = await cookies();\n    const token = cookieStore.get('admin-token')?.value;\n    \n    // For development, we'll allow access with a simple token check\n    if (token === 'dev_admin_token') {\n      return { \n        adminId: \"dev_admin\", \n        name: \"Development Admin\",\n        email: \"admin@docuploaer.com\",\n        role: \"admin\"\n      };\n    }\n\n    if (!token) {\n      throw new Error('No admin authentication token found');\n    }\n\n    // Verify the token with Firebase Admin\n    const decodedToken = await adminAuth.verifyIdToken(token);\n    \n    // Check if this is a custom token with admin role\n    if (decodedToken.role === 'admin') {\n      return {\n        adminId: decodedToken.adminId || decodedToken.uid,\n        name: decodedToken.name || 'Admin',\n        email: decodedToken.email || 'admin@example.com',\n        role: \"admin\"\n      };\n    }\n    \n    // Get admin data from admins collection\n    const adminDoc = await adminDb.collection('admins').doc(decodedToken.uid).get();\n    \n    if (!adminDoc.exists) {\n      throw new Error('Admin not found in database');\n    }\n\n    const adminData = adminDoc.data();\n    \n    if (!adminData?.isActive) {\n      throw new Error('Admin account is deactivated');\n    }\n\n    return {\n      adminId: decodedToken.uid,\n      name: adminData.name,\n      email: adminData.email,\n      role: \"admin\"\n    };\n  } catch (error) {\n    // For development, return default admin even on error\n    return { \n      adminId: \"dev_admin\", \n      name: \"Development Admin\",\n      email: \"admin@docuploaer.com\",\n      role: \"admin\"\n    };\n  }\n}\n\n// Helper function to get query parameters\nexport function getQueryParams(request: NextRequest) {\n  const { searchParams } = new URL(request.url);\n  return {\n    filter: searchParams.get('filter') || 'all',\n    dateFilter: searchParams.get('dateFilter') || 'all',\n    search: searchParams.get('search') || '',\n    limit: parseInt(searchParams.get('limit') || '50'),\n    offset: parseInt(searchParams.get('offset') || '0'),\n    status: searchParams.get('status'),\n    userId: searchParams.get('userId'),\n    fileId: searchParams.get('fileId'),\n    startDate: searchParams.get('startDate'),\n    endDate: searchParams.get('endDate')\n  };\n}\n"],"names":[],"mappings":";;;;;;AACA;AACA;;;;;;;AAGO,eAAe;IACpB,IAAI;QACF,MAAM,cAAc,MAAM,IAAA,4IAAO;QACjC,MAAM,QAAQ,YAAY,GAAG,CAAC,gBAAgB;QAE9C,gEAAgE;QAChE,IAAI,UAAU,mBAAmB;YAC/B,OAAO;gBACL,SAAS;gBACT,MAAM;gBACN,OAAO;gBACP,MAAM;YACR;QACF;QAEA,IAAI,CAAC,OAAO;YACV,MAAM,IAAI,MAAM;QAClB;QAEA,uCAAuC;QACvC,MAAM,eAAe,MAAM,sKAAS,CAAC,aAAa,CAAC;QAEnD,kDAAkD;QAClD,IAAI,aAAa,IAAI,KAAK,SAAS;YACjC,OAAO;gBACL,SAAS,aAAa,OAAO,IAAI,aAAa,GAAG;gBACjD,MAAM,aAAa,IAAI,IAAI;gBAC3B,OAAO,aAAa,KAAK,IAAI;gBAC7B,MAAM;YACR;QACF;QAEA,wCAAwC;QACxC,MAAM,WAAW,MAAM,oKAAO,CAAC,UAAU,CAAC,UAAU,GAAG,CAAC,aAAa,GAAG,EAAE,GAAG;QAE7E,IAAI,CAAC,SAAS,MAAM,EAAE;YACpB,MAAM,IAAI,MAAM;QAClB;QAEA,MAAM,YAAY,SAAS,IAAI;QAE/B,IAAI,CAAC,WAAW,UAAU;YACxB,MAAM,IAAI,MAAM;QAClB;QAEA,OAAO;YACL,SAAS,aAAa,GAAG;YACzB,MAAM,UAAU,IAAI;YACpB,OAAO,UAAU,KAAK;YACtB,MAAM;QACR;IACF,EAAE,OAAO,OAAO;QACd,sDAAsD;QACtD,OAAO;YACL,SAAS;YACT,MAAM;YACN,OAAO;YACP,MAAM;QACR;IACF;AACF;AAGO,SAAS,eAAe,OAAoB;IACjD,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,QAAQ,GAAG;IAC5C,OAAO;QACL,QAAQ,aAAa,GAAG,CAAC,aAAa;QACtC,YAAY,aAAa,GAAG,CAAC,iBAAiB;QAC9C,QAAQ,aAAa,GAAG,CAAC,aAAa;QACtC,OAAO,SAAS,aAAa,GAAG,CAAC,YAAY;QAC7C,QAAQ,SAAS,aAAa,GAAG,CAAC,aAAa;QAC/C,QAAQ,aAAa,GAAG,CAAC;QACzB,QAAQ,aAAa,GAAG,CAAC;QACzB,QAAQ,aAAa,GAAG,CAAC;QACzB,WAAW,aAAa,GAAG,CAAC;QAC5B,SAAS,aAAa,GAAG,CAAC;IAC5B;AACF","debugId":null}},
    {"offset": {"line": 286, "column": 0}, "map": {"version":3,"sources":["file:///D:/majalgav/hosting%20admin/apps/admin-app/src/app/api/admin/files/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { adminDb } from '@/lib/firebase-admin';\nimport { FieldPath } from 'firebase-admin/firestore';\nimport { serverCache, makeKey } from '@/lib/server-cache';\nimport { verifyAdminAuth } from '@/lib/admin-auth';\n\n// Helper function to handle Firestore connection issues with retry logic\nasync function withRetry<T>(\n  operation: () => Promise<T>,\n  maxRetries: number = 3,\n  delay: number = 1000\n): Promise<T> {\n  let lastError: any;\n  \n  for (let attempt = 1; attempt <= maxRetries; attempt++) {\n    try {\n      return await operation();\n    } catch (error: any) {\n      lastError = error;\n      \n      // Check if it's a connection error that we should retry\n      if (error.code === 14 || // UNAVAILABLE\n          error.message?.includes('No connection established') ||\n          error.message?.includes('network socket disconnected') ||\n          error.message?.includes('TLS connection') ||\n          error.code === 'ECONNRESET' ||\n          error.code === 'ENOTFOUND') {\n        \n        // Retrying...\n        \n        if (attempt < maxRetries) {\n          await new Promise(resolve => setTimeout(resolve, delay));\n          delay *= 2; // Exponential backoff\n          continue;\n        }\n      }\n      \n      // If it's not a retryable error or we've exhausted retries, throw\n      throw error;\n    }\n  }\n  \n  throw lastError;\n}\n\n// Helper function to trigger automatic assignment for paid files\nasync function triggerAutoAssignment(fileIds: string[]) {\n  try {\n    console.log(`[AUTO-ASSIGN] Triggering auto-assignment for ${fileIds.length} files`);\n    \n    // Get all active agents\n    const agentsSnapshot = await withRetry(() => adminDb.collection('agents')\n      .where('isActive', '==', true)\n      .get());\n\n    if (agentsSnapshot.empty) {\n      console.log('[AUTO-ASSIGN] No active agents found');\n      return { success: false, error: 'No active agents found' };\n    }\n\n    // OPTIMIZED: Get ALL assigned files with limit to prevent huge queries\n    const allAssignedFilesSnapshot = await withRetry(() => adminDb.collection('files')\n      .where('status', 'in', ['paid', 'assigned', 'in_progress'])\n      .limit(2000) // Limit to prevent huge queries\n      .get());\n\n    // Build workload map from single query result\n    const workloadMap = new Map<string, number>();\n    allAssignedFilesSnapshot.docs.forEach(doc => {\n      const agentId = doc.data().assignedAgentId;\n      if (agentId) {\n        workloadMap.set(agentId, (workloadMap.get(agentId) || 0) + 1);\n      }\n    });\n\n    // Calculate current workload for each agent (no additional queries needed!)\n    const agentWorkloads = agentsSnapshot.docs.map((agentDoc) => {\n      const agentData = agentDoc.data();\n      const agentId = agentDoc.id;\n\n      return {\n        agentId,\n        agentName: agentData.name || 'Unknown Agent',\n        agentEmail: agentData.email || 'No email',\n        currentWorkload: workloadMap.get(agentId) || 0, // O(1) lookup\n        maxWorkload: agentData.maxWorkload || 20,\n        isActive: agentData.isActive || false,\n        lastAssigned: agentData.lastAssigned || null\n      };\n    });\n\n    // Sort agents by workload (least loaded first)\n    const sortedAgents = agentWorkloads\n      .filter(agent => agent.isActive)\n      .sort((a, b) => {\n        if (a.currentWorkload !== b.currentWorkload) {\n          return a.currentWorkload - b.currentWorkload;\n        }\n        if (a.lastAssigned && b.lastAssigned) {\n          return new Date(a.lastAssigned).getTime() - new Date(b.lastAssigned).getTime();\n        }\n        if (!a.lastAssigned && b.lastAssigned) return -1;\n        if (a.lastAssigned && !b.lastAssigned) return 1;\n        return 0;\n      });\n\n    if (sortedAgents.length === 0) {\n      console.log('[AUTO-ASSIGN] No available agents for assignment');\n      return { success: false, error: 'No available agents for assignment' };\n    }\n\n    // Assign files to agents using round-robin with workload consideration\n    const assignments = [];\n    const agentUpdates = new Map<string, Date>();\n    let agentIndex = 0;\n\n    // OPTIMIZED: Use Firestore batch writes (up to 500 operations per batch)\n    const batch = adminDb.batch();\n    let operationCount = 0;\n    const MAX_BATCH_SIZE = 500;\n\n    for (const fileId of fileIds) {\n      // Find the best agent for this file\n      let selectedAgent = null;\n      \n      // Try to find an agent with available capacity\n      for (let i = 0; i < sortedAgents.length; i++) {\n        const agent = sortedAgents[agentIndex % sortedAgents.length];\n        agentIndex++;\n        \n        if (agent.currentWorkload < agent.maxWorkload) {\n          selectedAgent = agent;\n          break;\n        }\n      }\n\n      // If no agent has capacity, assign to the least loaded one\n      if (!selectedAgent) {\n        selectedAgent = sortedAgents[0];\n      }\n\n      // Add file update to batch\n      const fileRef = adminDb.collection('files').doc(fileId);\n      batch.update(fileRef, {\n        assignedAgentId: selectedAgent.agentId,\n        assignedAt: new Date(),\n        status: 'assigned',\n        updatedAt: new Date()\n      });\n      operationCount++;\n\n      // Track agent update (will be batched later)\n      agentUpdates.set(selectedAgent.agentId, new Date());\n\n      // Update agent's workload count\n      selectedAgent.currentWorkload++;\n\n      assignments.push({\n        fileId,\n        agentId: selectedAgent.agentId,\n        agentName: selectedAgent.agentName,\n        workload: selectedAgent.currentWorkload\n      });\n\n      // Commit batch if we hit the limit\n      if (operationCount >= MAX_BATCH_SIZE) {\n        await batch.commit();\n        operationCount = 0;\n      }\n    }\n\n    // Add agent updates to batch\n    agentUpdates.forEach((lastAssigned, agentId) => {\n      const agentRef = adminDb.collection('agents').doc(agentId);\n      batch.update(agentRef, {\n        lastAssigned,\n        updatedAt: new Date()\n      });\n      operationCount++;\n    });\n\n    // Commit any remaining operations\n    if (operationCount > 0) {\n      await batch.commit();\n    }\n    \n    return {\n      success: true,\n      message: `Successfully auto-assigned ${fileIds.length} file(s)`,\n      assignments: assignments,\n      totalAssigned: fileIds.length\n    };\n\n  } catch (error) {\n    console.error('[AUTO-ASSIGN] Error in auto-assignment:', error);\n    return { success: false, error: 'Auto-assignment failed' };\n  }\n}\n\nexport async function GET(request: NextRequest) {\n  try {\n    // Verify admin authentication\n    const admin = await verifyAdminAuth();\n    if (!admin) {\n      return NextResponse.json({ success: false, error: 'Unauthorized' }, { status: 401 });\n    }\n\n    const { searchParams } = new URL(request.url);\n    const page = parseInt(searchParams.get('page') || '1');\n    const limit = parseInt(searchParams.get('limit') || '50');\n    const search = searchParams.get('search') || '';\n    const status = searchParams.get('status') || 'all';\n    const assignedAgent = searchParams.get('assignedAgent') || 'all';\n\n    const fresh = searchParams.get('fresh') === '1';\n    const cacheKey = makeKey('files', ['list', page, limit, status || 'all', assignedAgent || 'all', search || '']);\n    const cached = fresh ? undefined : serverCache.get<any>(cacheKey);\n    if (cached) {\n      return NextResponse.json(cached);\n    }\n\n    // Build optimized query with filters at database level\n    let baseQuery: FirebaseFirestore.Query = adminDb.collection('files');\n    \n    // Apply status filter at database level\n    if (status !== 'all') {\n      baseQuery = baseQuery.where('status', '==', status);\n    }\n    \n    // Apply agent filter at database level\n    if (assignedAgent !== 'all') {\n      baseQuery = baseQuery.where('assignedAgentId', '==', assignedAgent);\n    }\n    \n    // Prefer indexed sort when available\n    let filesSnapshot: FirebaseFirestore.QuerySnapshot;\n    try {\n      const indexedQuery = baseQuery.orderBy('uploadedAt', 'desc').limit(1000);\n      filesSnapshot = await withRetry(() => indexedQuery.get());\n    } catch (err: any) {\n      // Fallback if composite index is missing: fetch without orderBy and sort in memory\n      if (err?.code === 9 || err?.message?.includes('requires an index')) {\n        const fallbackSnapshot = await withRetry(() => baseQuery.limit(1000).get());\n        // Sort docs in-memory by uploadedAt desc to preserve expected ordering\n        const sortedDocs = fallbackSnapshot.docs.sort((a, b) => {\n          const aTime = a.data()?.uploadedAt?.toDate?.()?.getTime?.() ?? new Date(a.data()?.uploadedAt || 0).getTime();\n          const bTime = b.data()?.uploadedAt?.toDate?.()?.getTime?.() ?? new Date(b.data()?.uploadedAt || 0).getTime();\n          return bTime - aTime;\n        });\n        // Create a lightweight snapshot-like object\n        filesSnapshot = {\n          docs: sortedDocs,\n          empty: sortedDocs.length === 0,\n          forEach: (cb: any) => sortedDocs.forEach(cb),\n          size: sortedDocs.length,\n          // Unused properties in our code path; add minimal stubs to satisfy types\n          metadata: undefined as any,\n          query: undefined as any\n        } as unknown as FirebaseFirestore.QuerySnapshot;\n      } else {\n        throw err;\n      }\n    }\n\n    // Extract unique user and agent IDs for batch fetching\n    const userIds = new Set<string>();\n    const agentIds = new Set<string>();\n    \n    const filesData = filesSnapshot.docs.map(doc => {\n      const data = doc.data();\n      if (data.userId) userIds.add(data.userId);\n      if (data.assignedAgentId) agentIds.add(data.assignedAgentId);\n      return { id: doc.id, ...data };\n    });\n\n    // OPTIMIZED: Batch fetch users and agents with limits\n    const [usersSnapshot, agentsSnapshot] = await Promise.all([\n      userIds.size > 0 \n        ? withRetry(() => adminDb.collection('users')\n            .where(FieldPath.documentId(), 'in', Array.from(userIds).slice(0, 10))\n            .limit(100) // Additional limit\n            .get())\n        : Promise.resolve({ docs: [] } as any),\n      agentIds.size > 0\n        ? withRetry(() => adminDb.collection('agents')\n            .where(FieldPath.documentId(), 'in', Array.from(agentIds).slice(0, 10))\n            .limit(100) // Additional limit\n            .get())\n        : Promise.resolve({ docs: [] } as any)\n    ]);\n\n    // Skip additional batch processing for performance - use only first 10 IDs\n    // This prevents excessive queries that slow down the API\n\n\n    // Create lookup maps for O(1) access\n    const usersMap = new Map();\n    usersSnapshot.docs.forEach((doc: any) => {\n      const data = doc.data();\n      usersMap.set(doc.id, {\n        id: doc.id,\n        name: data?.name || 'Unknown',\n        email: data?.email || 'Unknown',\n        phone: data?.phone || 'Unknown'\n      });\n    });\n\n    const agentsMap = new Map();\n    agentsSnapshot.docs.forEach((doc: any) => {\n      const data = doc.data();\n      agentsMap.set(doc.id, {\n        id: doc.id,\n        name: data?.name || 'Unknown',\n        email: data?.email || 'Unknown',\n        phone: data?.phone || 'Unknown'\n      });\n    });\n\n    // Map files with user and agent data from lookup maps (O(N) instead of O(N*M))\n    let files = filesData.map(data => ({\n      id: data.id,\n      filename: data.filename || 'Unknown',\n      originalName: data.originalName || 'Unknown',\n      size: data.size || 0,\n      mimeType: data.mimeType || 'Unknown',\n      status: data.status || 'unknown',\n      uploadedAt: data.uploadedAt?.toDate?.() || data.uploadedAt || new Date(),\n      assignedAt: data.assignedAt?.toDate?.() || data.assignedAt || null,\n      respondedAt: data.respondedAt?.toDate?.() || data.respondedAt || null,\n      responseFileURL: data.responseFileURL || null,\n      responseMessage: data.responseMessage || null,\n      user: data.userId ? usersMap.get(data.userId) || null : null,\n      agent: data.assignedAgentId ? agentsMap.get(data.assignedAgentId) || null : null,\n      paymentId: data.paymentId || null\n    }));\n\n    // Apply search filter\n    if (search) {\n      const searchLower = search.toLowerCase();\n      files = files.filter(file => \n        file.filename.toLowerCase().includes(searchLower) ||\n        file.originalName.toLowerCase().includes(searchLower) ||\n        file.user?.name?.toLowerCase().includes(searchLower) ||\n        file.user?.email?.toLowerCase().includes(searchLower) ||\n        file.agent?.name?.toLowerCase().includes(searchLower)\n      );\n    }\n\n    // Apply pagination\n    const totalFiles = files.length;\n    const startIndex = (Number(page) - 1) * Number(limit);\n    const endIndex = startIndex + Number(limit);\n    const paginatedFiles = files.slice(startIndex, endIndex);\n\n    const responsePayload = {\n      success: true,\n      files: paginatedFiles,\n      pagination: {\n        page: Number(page),\n        limit: Number(limit),\n        total: totalFiles,\n        pages: Math.ceil(totalFiles / Number(limit))\n      }\n    };\n\n    // Use shorter TTL to reduce staleness after payments; skip caching if explicitly fresh\n    if (!fresh) {\n      serverCache.set(cacheKey, responsePayload, 10_000); // 10s TTL for fresher files list\n    }\n    return NextResponse.json(responsePayload);\n\n  } catch (error: any) {\n    console.error('Error fetching files:', error);\n    \n    // Handle specific error types\n    if (error.code === 14 || error.message?.includes('No connection established')) {\n      return NextResponse.json(\n        { success: false, error: \"Database connection failed. Please try again.\" },\n        { status: 503 }\n      );\n    }\n    \n    if (error.name === 'AbortError' || error.message?.includes('timeout')) {\n      return NextResponse.json(\n        { success: false, error: \"Request timed out. Please try again.\" },\n        { status: 408 }\n      );\n    }\n    \n    return NextResponse.json(\n      { success: false, error: 'Failed to fetch files' },\n      { status: 500 }\n    );\n  }\n}\n\nexport async function PATCH(request: NextRequest) {\n  try {\n    // Verify admin authentication\n    const admin = await verifyAdminAuth();\n    if (!admin) {\n      return NextResponse.json({ success: false, error: 'Unauthorized' }, { status: 401 });\n    }\n\n    const { fileId, status, assignedAgentId, responseMessage } = await request.json();\n\n    if (!fileId) {\n      return NextResponse.json({ success: false, error: 'File ID is required' }, { status: 400 });\n    }\n\n    const updateData: any = {};\n\n    if (status) {\n      updateData.status = status;\n    }\n\n    if (assignedAgentId) {\n      updateData.assignedAgentId = assignedAgentId;\n      updateData.assignedAt = new Date();\n    }\n\n    if (responseMessage) {\n      updateData.responseMessage = responseMessage;\n    }\n\n    updateData.updatedAt = new Date();\n\n    await adminDb.collection('files').doc(fileId).update(updateData);\n    serverCache.deleteByPrefix(makeKey('files'));\n\n    // Auto-assign if file status changed to 'paid' and no agent is assigned\n    if (status === 'paid' && !assignedAgentId) {\n      try {\n        console.log('File marked as paid, triggering auto-assignment for:', fileId);\n        const autoAssignResult = await triggerAutoAssignment([fileId]);\n        \n        if (autoAssignResult.success) {\n          console.log('Auto-assignment successful:', autoAssignResult);\n        } else {\n          console.error('Auto-assignment failed:', autoAssignResult);\n        }\n      } catch (error) {\n        console.error('Error in auto-assignment trigger:', error);\n      }\n    }\n\n    // Log the action\n    await adminDb.collection('logs').add({\n      action: 'file_updated',\n      adminId: admin.adminId,\n      adminName: admin.name,\n      fileId,\n      changes: updateData,\n      autoAssigned: status === 'paid' && !assignedAgentId,\n      timestamp: new Date()\n    });\n\n    return NextResponse.json({\n      success: true,\n      message: 'File updated successfully'\n    });\n\n  } catch (error: any) {\n    console.error('Error updating file:', error);\n    return NextResponse.json(\n      { success: false, error: 'Failed to update file' },\n      { status: 500 }\n    );\n  }\n}\n\n// PUT - Update file status and trigger auto-assignment if needed\nexport async function PUT(request: NextRequest) {\n  try {\n    const admin = await verifyAdminAuth();\n    if (!admin) {\n      return NextResponse.json({ success: false, error: 'Unauthorized' }, { status: 401 });\n    }\n\n    const { fileId, status, triggerAutoAssign = false } = await request.json();\n\n    if (!fileId || !status) {\n      return NextResponse.json({ \n        success: false, \n        error: 'File ID and status are required' \n      }, { status: 400 });\n    }\n\n    // Update file status\n    const updateData: any = {\n      status,\n      updatedAt: new Date()\n    };\n\n    await adminDb.collection('files').doc(fileId).update(updateData);\n    serverCache.deleteByPrefix(makeKey('files'));\n\n    // If status is 'paid' and auto-assignment is enabled, trigger it\n    if (status === 'paid' && triggerAutoAssign) {\n      const autoAssignResult = await triggerAutoAssignment([fileId]);\n      \n      if (autoAssignResult.success) {\n        return NextResponse.json({\n          success: true,\n          message: 'File status updated and auto-assigned successfully',\n          autoAssignment: autoAssignResult\n        });\n      } else {\n        return NextResponse.json({\n          success: true,\n          message: 'File status updated, but auto-assignment failed',\n          autoAssignment: autoAssignResult\n        });\n      }\n    }\n\n    // Log the action\n    await adminDb.collection('logs').add({\n      action: 'file_status_updated',\n      adminId: admin.adminId,\n      adminName: admin.name,\n      fileId,\n      newStatus: status,\n      triggerAutoAssign,\n      timestamp: new Date()\n    });\n\n    return NextResponse.json({\n      success: true,\n      message: 'File status updated successfully'\n    });\n\n  } catch (error: any) {\n    console.error('Error updating file status:', error);\n    return NextResponse.json(\n      { success: false, error: 'Failed to update file status' },\n      { status: 500 }\n    );\n  }\n}\n\nexport async function DELETE(request: NextRequest) {\n  try {\n    // Verify admin authentication\n    const admin = await verifyAdminAuth();\n    if (!admin) {\n      return NextResponse.json({ success: false, error: 'Unauthorized' }, { status: 401 });\n    }\n\n    const { fileId, fileIds } = await request.json();\n\n    const idsToDelete: string[] = Array.isArray(fileIds)\n      ? fileIds.filter(Boolean)\n      : (fileId ? [fileId] : []);\n\n    if (!idsToDelete.length) {\n      return NextResponse.json({ success: false, error: 'File ID(s) are required' }, { status: 400 });\n    }\n\n    // Batch delete (limit 500 per batch)\n    let deletedCount = 0;\n    const chunks: string[][] = [];\n    for (let i = 0; i < idsToDelete.length; i += 500) {\n      chunks.push(idsToDelete.slice(i, i + 500));\n    }\n\n    for (const chunk of chunks) {\n      const batch = adminDb.batch();\n      const fileDocs = await Promise.all(chunk.map(id => adminDb.collection('files').doc(id).get()));\n      fileDocs.forEach((doc, idx) => {\n        if (doc.exists) {\n          const id = chunk[idx];\n          batch.delete(doc.ref);\n          // Log each deletion\n          const data = doc.data();\n          const logRef = adminDb.collection('logs').doc();\n          batch.set(logRef, {\n            action: 'file_deleted',\n            adminId: admin.adminId,\n            adminName: admin.name,\n            fileId: id,\n            fileName: data?.filename || 'Unknown',\n            originalName: data?.originalName || 'Unknown',\n            userId: data?.userId || 'Unknown',\n            timestamp: new Date()\n          });\n          deletedCount += 1;\n        }\n      });\n      await batch.commit();\n    }\n\n    serverCache.deleteByPrefix(makeKey('files'));\n\n    return NextResponse.json({\n      success: true,\n      message: deletedCount === 1 ? 'File deleted successfully' : `Deleted ${deletedCount} files`,\n      deletedCount\n    });\n\n  } catch (error: any) {\n    console.error('Error deleting file:', error);\n    return NextResponse.json(\n      { success: false, error: 'Failed to delete file' },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}}]
}